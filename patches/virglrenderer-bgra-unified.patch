--- a/src/vrend/vrend_renderer.c	2026-01-30 06:27:14
+++ b/src/vrend/vrend_renderer.c	2026-02-01 00:36:40
@@ -889,6 +889,8 @@
                                       struct vrend_sampler_view *tview);
 static void vrend_object_bind_dsa_to_sub_context(struct vrend_sub_context *sub_ctx,
                                                  uint32_t handle);
+
+static void vrend_swizzle_data_bgra(uint64_t size, void *data);
 static GLenum tgsitargettogltarget(const enum pipe_texture_target target, int nr_samples);
 
 void vrend_update_stencil_state(struct vrend_sub_context *sub_ctx);
@@ -3116,6 +3118,8 @@
          glDisable(GL_FRAMEBUFFER_SRGB_EXT);
       }
       sub_ctx->framebuffer_srgb_enabled = use_srgb;
+
+   uint32_t prev_swizzle = sub_ctx->swizzle_output_rgb_to_bgr;
    }
 
    sub_ctx->swizzle_output_rgb_to_bgr = 0;
@@ -3130,7 +3134,22 @@
        * be necessary, e.g. for rgb* views on bgr* resources. Ensure this
        * happens by adding a shader swizzle to the final write of such surfaces.
        */
-      if (vrend_resource_needs_redblue_swizzle(surf->texture, surf->format))
+      bool needs_swizzle = vrend_resource_needs_redblue_swizzle(surf->texture, surf->format);
+
+      /* In Core Profile, BGRA formats need special handling since GL_BGRA is not supported */
+      if (!needs_swizzle && vrend_state.use_core_profile && vrend_format_is_bgra(surf->format)) {
+         const struct vrend_format_table *format_entry = &tex_conv_table[surf->format];
+         /* format-override.patch converts BGRA to GL_RGBA with texture swizzle.
+          * Only add shader output swizzle for BGRA formats NOT already converted. */
+         if (format_entry->glformat != GL_RGBA) {
+            VREND_DEBUG(dbg_bgra, sub_ctx->parent,
+                        "FB attachment %u: BGRA format=%s without texture swizzle, adding shader output swizzle\n",
+                        i, util_format_name(surf->format));
+            needs_swizzle = true;
+         }
+      }
+
+      if (needs_swizzle)
          sub_ctx->swizzle_output_rgb_to_bgr |= 1 << i;
 
       /* glTextureView() on eglimage-backed bgr* textures for is not supported.
@@ -3147,6 +3166,19 @@
       }
    }
 
+   /* Invalidate fragment shaders if swizzle state changed (Core Profile only) */
+   if (vrend_state.use_core_profile && sub_ctx->swizzle_output_rgb_to_bgr != prev_swizzle) {
+      VREND_DEBUG(dbg_bgra, sub_ctx->parent, "Shader swizzle state changed: 0x%x -> 0x%x, invalidating shaders\n",
+                  prev_swizzle, sub_ctx->swizzle_output_rgb_to_bgr);
+      sub_ctx->shader_dirty = true;
+      VREND_DEBUG(dbg_bgra, sub_ctx->parent, "Forcing shader recompile due to swizzle change\n");
+      if (sub_ctx->shaders[PIPE_SHADER_FRAGMENT] && sub_ctx->shaders[PIPE_SHADER_FRAGMENT]->current) {
+         VREND_DEBUG(dbg_bgra, sub_ctx->parent, "Invalidating cached shader (current=%p)\n",
+                     sub_ctx->shaders[PIPE_SHADER_FRAGMENT]->current);
+         sub_ctx->shaders[PIPE_SHADER_FRAGMENT]->current->key.fs.swizzle_output_rgb_to_bgr = 0xff;
+      }
+   }
+
    glDrawBuffers(sub_ctx->nr_cbufs, buffers);
 }
 
@@ -3455,6 +3487,45 @@
       return;
    }
 
+   /* In Core Profile, CPU-swizzle vertex buffers with BGRA color data */
+   if (vrend_state.use_core_profile && v->zyxw_bitmask) {
+      VREND_DEBUG(dbg_bgra, ctx, "[BGRA SWIZZLE] Binding vertex elements with zyxw_bitmask=0x%x, swizzling buffers\n", v->zyxw_bitmask);
+      for (uint32_t i = 0; i < v->count; i++) {
+         if (!(v->zyxw_bitmask & (1 << i)))
+            continue;
+
+         struct vrend_vertex_element *ve = &v->elements[i];
+         struct vrend_vertex_buffer *vbo = &ctx->sub->vbo[ve->base.vertex_buffer_index];
+         if (!vbo || !vbo->base.buffer) {
+            VREND_DEBUG(dbg_bgra, ctx, "[BGRA SWIZZLE] Element %u: no VBO/buffer\n", i);
+            continue;
+         }
+
+         struct vrend_resource *res = (struct vrend_resource *)vbo->base.buffer;
+         if (!res || res->base.target != PIPE_BUFFER || res->bgra_swizzled) {
+            if (res && res->bgra_swizzled)
+               VREND_DEBUG(dbg_bgra, ctx, "[BGRA SWIZZLE] Element %u: already swizzled\n", i);
+            else if (!res)
+               VREND_DEBUG(dbg_bgra, ctx, "[BGRA SWIZZLE] Element %u: no resource or not PIPE_BUFFER\n", i);
+            continue;
+         }
+
+         VREND_DEBUG(dbg_bgra, ctx, "[BGRA SWIZZLE] Element %u: mapping and swizzling (size=%u)\n", i, res->base.width0);
+         glBindBuffer(GL_ARRAY_BUFFER, res->gl_id);
+         void *data = glMapBufferRange(GL_ARRAY_BUFFER, 0, res->base.width0,
+                                        GL_MAP_WRITE_BIT | GL_MAP_READ_BIT);
+         if (data) {
+            vrend_swizzle_data_bgra(res->base.width0, data);
+            glUnmapBuffer(GL_ARRAY_BUFFER);
+            res->bgra_swizzled = true;
+            VREND_DEBUG(dbg_bgra, ctx, "[BGRA SWIZZLE] Element %u: successfully swizzled\n", i);
+         } else {
+            VREND_DEBUG(dbg_bgra, ctx, "[BGRA SWIZZLE] Element %u: failed to map buffer\n", i);
+         }
+         glBindBuffer(GL_ARRAY_BUFFER, 0);
+      }
+   }
+
    if (has_feature(feat_gles31_vertex_attrib_binding) && v->id == 0) {
       glGenVertexArrays(1, &v->id);
       glBindVertexArray(v->id);
--- a/src/vrend/vrend_renderer.h	2026-01-30 06:27:14
+++ b/src/vrend/vrend_renderer.h	2026-02-01 00:23:31
@@ -117,6 +117,7 @@
    uint32_t blob_id;
    struct list_head head;
    bool is_imported;
+   bool bgra_swizzled;
 };
 
 #define VIRGL_TEXTURE_NEED_SWIZZLE        (1 << 0)
--- a/src/vrend/vrend_shader.c	2026-01-30 06:27:14
+++ b/src/vrend/vrend_shader.c	2026-02-01 00:23:31
@@ -2712,8 +2712,10 @
     if (ctx->key->fs.logicop_enabled)
        emit_fragment_logicop(ctx, glsl_strbufs);
+   printf("SHADER SWIZZLE: handle_fragment_proc_exit: swizzle_output_rgb_to_bgr=%d\n",
+          ctx->key->fs.swizzle_output_rgb_to_bgr);
 
-    if (ctx->key->fs.swizzle_output_rgb_to_bgr)
+   if (ctx->key->fs.swizzle_output_rgb_to_bgr)
        emit_cbuf_swizzle(ctx, glsl_strbufs);
 
     if (ctx->key->fs.needs_manual_srgb_encode_bitmask)

--- a/meson.build	2023-06-29 20:46:58
+++ b/meson.build	2025-12-11 15:17:20
@@ -23,7 +23,7 @@
 
 project(
    'virglrenderer', 'c',
-   version: '0.10.4',
+   version: '1.2.0',
    license : 'MIT',
    meson_version : '>= 0.55',
    default_options : ['buildtype=release', 'b_ndebug=if-release',
@@ -33,14 +33,21 @@
 # To change only before doing a release:
 #
 # 1. Incrememnt the revision
-# 2. If the interface was changed in an compatible way increment the
-#    interface age
-# 3. If the ABI has changed in an incompatible way increment the binary_age
-#    and set revision and interface_age to zero
+# 2. If the interface was changed in a compatible way (i.e. interfaces
+#    were only added) increment "interface age" and set "revision" to zero 
+# 3. If the ABI has changed in an incompatible way increment "binary_age"
+#    and set "revision" and "interface_age" to zero
+
 binary_age    = 1
-interface_age = 7
-revision      = 7
+interface_age = 10
+revision      = 0
 
+virgl_version = meson.project_version()
+version_array = virgl_version.split('.')
+virgl_major_version = version_array[0].to_int()
+virgl_minor_version = version_array[1].to_int()
+virgl_micro_version = version_array[2].to_int()
+
 cc = meson.get_compiler('c')
 
 if cc.get_id() == 'gcc' and cc.version().version_compare('< 4.1')
@@ -58,12 +65,14 @@
    '-Werror=switch',
    '-Wno-overlength-strings',
    '-Wno-missing-field-initializers',
+   '-Werror=format',
 ]
 
 add_project_arguments(cc.get_supported_arguments(warnings), language : 'c')
 
 flags = [
    '-fvisibility=hidden',
+   '-fno-strict-aliasing',
 ]
 
 add_project_arguments(cc.get_supported_arguments(flags), language : 'c')
@@ -71,7 +80,6 @@
 prog_python = import('python').find_installation('python3')
 
 not_found = dependency('', required: false)
-libdrm_dep = dependency('libdrm', version : '>=2.4.50', required: get_option('drm').enabled() or get_option('venus'))
 gbm_dep = not_found
 thread_dep = dependency('threads')
 epoxy_dep = dependency('epoxy', version: '>= 1.5.4')
@@ -80,9 +88,43 @@
 conf_data = configuration_data()
 conf_data.set('VERSION', meson.project_version())
 conf_data.set('_GNU_SOURCE', 1)
+# Compile unstable APIs unconditionally to avoid building two variants of
+# the lib. It's up to virglrenderer users to decide whether to use these
+# APIs. Unstable APIs may be changed or removed without a notice.
 conf_data.set('VIRGL_RENDERER_UNSTABLE_APIS', 1)
-conf_data.set('ENABLE_DRM', libdrm_dep.found())
 
+drm_renderers = get_option('drm-renderers')
+
+with_drm_msm = drm_renderers.contains('msm')
+if with_drm_msm
+  conf_data.set('ENABLE_DRM_MSM', 1)
+endif
+
+with_drm_amdgpu = drm_renderers.contains('amdgpu-experimental')
+if with_drm_amdgpu
+  conf_data.set('ENABLE_DRM_AMDGPU', 1)
+endif
+
+with_drm_asahi = drm_renderers.contains('asahi')
+if with_drm_asahi
+  conf_data.set('ENABLE_DRM_ASAHI', 1)
+endif
+
+with_drm_renderers = drm_renderers.length() > 0
+
+if with_drm_renderers
+  conf_data.set('ENABLE_DRM', 1)
+endif
+
+libdrm_dep = dependency('libdrm', version : '>=2.4.50', required: with_drm_renderers or get_option('video'))
+libdrm_amdgpu_dep = dependency('libdrm_amdgpu', version : '>=2.4.121', required: with_drm_amdgpu)
+conf_data.set('ENABLE_LIBDRM', libdrm_dep.found())
+drm_uapi_dep = declare_dependency(
+   include_directories: include_directories('src' / 'drm' / 'drm-uapi')
+)
+
+pkg_cflags = []
+
 has_attribute_cleanup = cc.compiles('''
    void func(void *v) {}
    int main ()
@@ -128,7 +170,10 @@
    conf_data.set('HAVE_DLFCN_H', 1)
 endif
 
-if thread_dep.found() and host_machine.system() != 'windows'
+with_host_windows = host_machine.system() == 'windows'
+with_host_darwin = host_machine.system() == 'darwin'
+
+if thread_dep.found() and not with_host_windows
   conf_data.set('HAVE_PTHREAD', 1)
   if host_machine.system() != 'netbsd' and cc.has_function(
       'pthread_setaffinity_np',
@@ -137,6 +182,9 @@
       args : '-D_GNU_SOURCE')
     conf_data.set('HAVE_PTHREAD_SETAFFINITY', 1)
   endif
+  if cc.has_header('pthread_np.h')
+     conf_data.set('HAVE_PTHREAD_NP_H', 1)
+  endif
 endif
 
 if cc.has_header('sys/eventfd.h')
@@ -147,6 +195,14 @@
   conf_data.set('HAVE_SYS_SELECT_H', 1)
 endif
 
+if cc.has_header('linux/dma-buf.h')
+   conf_data.set('HAVE_DMABUF_H', 1)
+endif
+
+if cc.has_header('linux/udmabuf.h')
+   conf_data.set('HAVE_LINUX_UDMABUF_H', 1)
+endif
+
 foreach b : ['bswap32', 'bswap64', 'clz', 'clzll', 'expect', 'ffs', 'ffsll',
              'popcount', 'popcountll', 'types_compatible_p', 'unreachable']
   if cc.has_function(b)
@@ -156,10 +212,17 @@
 
 supported_function_attributes = cc.get_supported_function_attributes([
   'const', 'flatten', 'format', 'malloc', 'noreturn', 'packed', 'pure',
-  'returns_nonnull', 'unused', 'warn_unused_result', 'weak',
+  'returns_nonnull', 'unused', 'warn_unused_result', 'weak', 'aligned'
 ])
+have_struct_attribute_packed = false
+have_struct_attribute_aligned = false
 foreach a : supported_function_attributes
-    conf_data.set('HAVE_FUNC_ATTRIBUTE_@0@'.format(a.to_upper()), 1)
+  conf_data.set('HAVE_FUNC_ATTRIBUTE_@0@'.format(a.to_upper()), 1)
+  if a == 'packed'
+    have_struct_attribute_packed = true
+  elif a == 'aligned'
+    have_struct_attribute_aligned = true
+  endif
 endforeach
 
 foreach f : ['memfd_create', 'strtok_r', 'timespec_get']
@@ -216,6 +279,7 @@
 
 with_minigbm_allocation = get_option('minigbm_allocation')
 if with_minigbm_allocation
+   assert(not with_host_windows, 'minigbm allocation is not supported by windows host')
    conf_data.set('ENABLE_MINIGBM_ALLOCATION', 1)
    _gbm_ver = '18.0.0'
 else
@@ -224,12 +288,16 @@
 
 if with_egl
    if cc.has_header('epoxy/egl.h', dependencies: epoxy_dep) and epoxy_dep.get_variable(pkgconfig: 'epoxy_has_egl') == '1'
-      have_egl = true
-      conf_data.set('HAVE_EPOXY_EGL_H', 1)
-      if libdrm_dep.found()
-         gbm_dep = dependency('gbm', version: '>= ' + _gbm_ver, required: require_egl)
+      if with_host_windows or with_host_darwin
+         have_egl = true
+      else
+         if libdrm_dep.found()
+            gbm_dep = dependency('gbm', version: '>= ' + _gbm_ver, required: require_egl)
+         endif
+         have_egl = gbm_dep.found() and cc.has_header('sys/mman.h', required: require_egl)
+         conf_data.set('ENABLE_GBM', have_egl)
       endif
-      conf_data.set('ENABLE_GBM', gbm_dep.found())
+      conf_data.set('HAVE_EPOXY_EGL_H', have_egl)
    else
       assert(not require_egl,
              'egl was explicitely requested but it is not supported by epoxy')
@@ -249,12 +317,17 @@
 
 have_vla = not cc.has_header_symbol('stdlib.h', '__STDC_NO_VLA__')
 
-# drm/msm support requires the compiler to support VLA:
-with_drm_msm = have_vla and get_option('drm-msm-experimental')
-if with_drm_msm
-  conf_data.set('ENABLE_DRM_MSM', 1)
+if with_drm_renderers
+   if (not have_struct_attribute_packed or
+       not have_struct_attribute_aligned or
+       not have_vla)
+      error('DRM renderers require compiler support for VLAs, packed and aligned structs')
+   endif
+
+   if (['arm'].contains(target_machine.cpu_family()) and with_drm_msm)
+      error('MSM renderer doesn\'t support 32bit ARM target')
+   endif
 endif
-with_drm = with_drm_msm
 
 with_check_gl_errors = get_option('check-gl-errors')
 if with_check_gl_errors
@@ -266,9 +339,25 @@
 with_render_server_worker = get_option('render-server-worker')
 render_server_install_dir = get_option('prefix') / get_option('libexecdir')
 if with_venus
-   gbm_dep = dependency('gbm')
-   venus_dep = dependency('vulkan')
+   if with_minigbm_allocation
+      gbm_dep = dependency('gbm')
+   endif
 
+   venus_dep = []
+   if get_option('vulkan-dload')
+      conf_data.set('ENABLE_VULKAN_DLOAD', 1)
+   else
+      venus_dep = dependency('vulkan')
+   endif
+
+   if host_machine.system() in ['freebsd', 'openbsd']
+      # When building for FreeBSD, epoll(7) is provided by a userspace
+      # wrapper around kqueue(2).
+      epoll_dep = dependency('epoll-shim')
+   else
+      epoll_dep = []
+   endif
+
    conf_data.set('ENABLE_VENUS', 1)
 
    if get_option('venus-validate')
@@ -287,6 +376,10 @@
       warning('set RENDER_SERVER_EXEC_PATH env if not install')
    endif
 
+   if get_option('vulkan-preload')
+      conf_data.set('ENABLE_VULKAN_PRELOAD', 1)
+   endif
+
    if with_render_server_worker == 'process'
       conf_data.set('ENABLE_RENDER_SERVER_WORKER_PROCESS', 1)
    elif with_render_server_worker == 'thread'
@@ -304,11 +397,19 @@
 
 with_video = get_option('video')
 if with_video
+  if not have_egl
+     error('video require EGL, but it is not available')
+  endif
   conf_data.set('ENABLE_VIDEO', 1)
   libva_dep = dependency('libva')
   libvadrm_dep = dependency('libva-drm')
 endif
 
+with_tests = get_option('tests')
+if with_tests
+ conf_data.set('ENABLE_TESTS', 1)
+endif
+
 configure_file(input : 'config.h.meson',
                output : 'config.h',
                configuration : conf_data)
@@ -319,11 +420,15 @@
 inc_configuration = include_directories(['.', 'src'])
 
 with_fuzzer = get_option('fuzzer')
-with_tests = get_option('tests')
 with_valgrind = get_option('valgrind')
 
+with_unstable_apis = get_option('unstable-apis')
+if with_unstable_apis
+  pkg_cflags += '-DVIRGL_RENDERER_UNSTABLE_APIS=1'
+endif
+
 subdir('src')
-if host_machine.system() != 'windows'
+if not with_host_windows
    subdir('vtest')
 endif
 
@@ -347,9 +452,11 @@
         'venus': with_venus,
         'drm-msm': with_drm_msm,
         'render server (DEPRECATED)': with_render_server,
+        'drm-amdgpu': with_drm_amdgpu,
         'render server worker': with_render_server ? with_render_server_worker : 'none',
         'video': with_video,
         'tests': with_tests,
         'fuzzer': with_fuzzer,
         'tracing': with_tracing,
+        'unstable-apis': with_unstable_apis,
         }, section: 'Configuration')
--- a/src/meson.build	2023-06-29 20:46:58
+++ b/src/meson.build	2025-12-11 15:17:20
@@ -25,100 +25,64 @@
 subdir('gallium')
 
 virgl_sources = [
-   'iov.c',
    'virgl_context.c',
-   'virgl_context.h',
-   'virgl_hw.h',
-   'virgl_protocol.h',
+   'virgl_fence.c',
    'virgl_resource.c',
-   'virgl_resource.h',
    'virgl_util.c',
-   'virgl_util.h',
 ]
 
 vrend_sources = [
-   'vrend_blitter.c',
-   'vrend_blitter.h',
-   'vrend_debug.c',
-   'vrend_debug.h',
-   'vrend_decode.c',
-   'vrend_formats.c',
-   'vrend_iov.h',
-   'vrend_object.c',
-   'vrend_object.h',
-   'vrend_renderer.c',
-   'vrend_renderer.h',
-   'vrend_shader.c',
-   'vrend_shader.h',
-   'vrend_strbuf.h',
-   'vrend_tweaks.c',
-   'vrend_tweaks.h',
-   'vrend_winsys.c',
-   'vrend_winsys.h',
+   'vrend/iov.c',
+   'vrend/vrend_blitter.c',
+   'vrend/vrend_debug.c',
+   'vrend/vrend_decode.c',
+   'vrend/vrend_formats.c',
+   'vrend/vrend_object.c',
+   'vrend/vrend_renderer.c',
+   'vrend/vrend_shader.c',
+   'vrend/vrend_tweaks.c',
+   'vrend/vrend_winsys.c',
 ]
 
 virglrenderer_sources = [
    'virglrenderer.c',
-   'virglrenderer.h',
-   'virglrenderer_hw.h',
 ]
 
 vrend_winsys_gbm_sources = [
-   'vrend_winsys_gbm.c',
-   'vrend_winsys_gbm.h',
+   'vrend/vrend_winsys_gbm.c',
 ]
 
 vrend_winsys_egl_sources = [
-   'vrend_winsys_egl.c',
-   'vrend_winsys_egl.h',
+   'vrend/vrend_winsys_egl.c',
 ]
 
 vrend_winsys_glx_sources = [
-   'vrend_winsys_glx.c',
-   'vrend_winsys_glx.h',
+   'vrend/vrend_winsys_glx.c',
 ]
 
 venus_sources = [
-   'venus_hw.h',
-   'venus/venus-protocol/vn_protocol_renderer.h',
+   'venus/vkr_acceleration_structure.c',
    'venus/vkr_allocator.c',
-   'venus/vkr_allocator.h',
    'venus/vkr_buffer.c',
-   'venus/vkr_buffer.h',
    'venus/vkr_command_buffer.c',
-   'venus/vkr_command_buffer.h',
    'venus/vkr_common.c',
-   'venus/vkr_common.h',
    'venus/vkr_context.c',
-   'venus/vkr_context.h',
    'venus/vkr_cs.c',
-   'venus/vkr_cs.h',
    'venus/vkr_descriptor_set.c',
-   'venus/vkr_descriptor_set.h',
    'venus/vkr_device.c',
-   'venus/vkr_device.h',
    'venus/vkr_device_memory.c',
-   'venus/vkr_device_memory.h',
+   'venus/vkr_host_copy.c',
    'venus/vkr_image.c',
-   'venus/vkr_image.h',
    'venus/vkr_instance.c',
-   'venus/vkr_instance.h',
+   'venus/vkr_library.c',
    'venus/vkr_physical_device.c',
-   'venus/vkr_physical_device.h',
    'venus/vkr_pipeline.c',
-   'venus/vkr_pipeline.h',
    'venus/vkr_query_pool.c',
-   'venus/vkr_query_pool.h',
    'venus/vkr_queue.c',
-   'venus/vkr_queue.h',
    'venus/vkr_render_pass.c',
-   'venus/vkr_render_pass.h',
    'venus/vkr_renderer.c',
-   'venus/vkr_renderer.h',
    'venus/vkr_ring.c',
-   'venus/vkr_ring.h',
    'venus/vkr_transport.c',
-   'venus/vkr_transport.h',
 ]
 
 venus_codegen = custom_target(
@@ -139,21 +103,27 @@
 )
 
 drm_sources = [
+   'drm/drm_context.c',
    'drm/drm_fence.c',
-   'drm/drm_fence.h',
    'drm/drm_renderer.c',
-   'drm/drm_renderer.h',
    'drm/drm_util.c',
-   'drm/drm_util.h',
 ]
 
 drm_msm_sources = [
-   'drm/drm-uapi/msm_drm.h',
-   'drm/msm/msm_proto.h',
    'drm/msm/msm_renderer.c',
-   'drm/msm/msm_renderer.h',
 ]
 
+drm_amdgpu_sources = [
+   'drm/amdgpu/amdgpu_renderer.c',
+]
+
+drm_asahi_sources = [
+   'drm/drm-uapi/asahi_drm.h',
+   'drm/asahi/asahi_proto.h',
+   'drm/asahi/asahi_renderer.c',
+   'drm/asahi/asahi_renderer.h',
+]
+
 proxy_sources = [
    'proxy/proxy_client.c',
    'proxy/proxy_common.c',
@@ -164,11 +134,8 @@
 ]
 
 video_sources = [
-   'virgl_video_hw.h',
-   'virgl_video.c',
-   'virgl_video.h',
-   'vrend_video.c',
-   'vrend_video.h',
+   'vrend/virgl_video.c',
+   'vrend/vrend_video.c',
 ]
 
 virgl_depends = [
@@ -213,7 +180,7 @@
    virgl_depends += [venus_dep]
 endif
 
-if with_drm
+if with_drm_renderers
    virgl_sources += drm_sources
 endif
 
@@ -221,6 +188,15 @@
    virgl_sources += drm_msm_sources
 endif
 
+if with_drm_amdgpu
+   virgl_sources += drm_amdgpu_sources
+   virgl_depends += [libdrm_amdgpu_dep]
+endif
+
+if with_drm_asahi
+   virgl_sources += drm_asahi_sources
+endif
+
 if with_render_server
    virgl_sources += proxy_sources
 endif
@@ -230,15 +206,15 @@
   virgl_depends += [libva_dep, libvadrm_dep]
 endif
 
-if host_machine.system() == 'windows'
+if with_host_windows
   virgl_sources += ['mman_win32.c']
 endif
 
 libvirgl = static_library(
    'virgl',
    virgl_sources,
-   include_directories: [inc_gallium, inc_configuration, 'venus', 'drm', 'drm/drm-uapi'],
-   dependencies : virgl_depends,
+   include_directories: [inc_gallium, inc_configuration, 'venus', 'drm'],
+   dependencies : [virgl_depends, drm_uapi_dep],
 )
 
 libvirgl_inc = [
@@ -256,7 +232,7 @@
    'virglrenderer',
    virglrenderer_sources,
    include_directories: [inc_gallium, inc_configuration],
-   dependencies : [virgl_depends, libvirgl_dep],
+   dependencies : [virgl_depends, libvirgl_dep, drm_uapi_dep],
    version : binary_age.to_string() + '.'
              + interface_age.to_string() + '.'
              + revision.to_string(),
@@ -266,6 +242,7 @@
 pkg = import('pkgconfig')
 pkg.generate(libvirglrenderer,
    description: 'virgl GL renderer',
+   extra_cflags: pkg_cflags,
    subdirs: 'virgl'
 )
 
@@ -275,4 +252,17 @@
    dependencies : [libvirgl_dep, gallium_dep]
 )
 
+# Version header
+version_conf = configuration_data()
+version_conf.set('VIRGL_MAJOR_VERSION', virgl_major_version)
+version_conf.set('VIRGL_MINOR_VERSION', virgl_minor_version)
+version_conf.set('VIRGL_MICRO_VERSION', virgl_micro_version)
+
+configure_file(
+  input: 'virgl-version.h.meson',
+  output: 'virgl-version.h',
+  configuration: version_conf,
+  install_dir: join_paths(get_option('includedir'), 'virgl'),
+)
+
 install_headers('virglrenderer.h', subdir : 'virgl')
diff -Naur a/src/virgl-version.h.meson b/src/virgl-version.h.meson
--- a/src/virgl-version.h.meson	1970-01-01
+++ b/src/virgl-version.h.meson
+/**************************************************************************
+ *
+ * Copyright (C) 2024 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ **************************************************************************/
+
+#ifndef VIRGL_VERSION_H
+#define VIRGL_VERSION_H
+
+/**
+ * VIRGL_MAJOR_VERSION:
+ *
+ * Evaluates to the major version number of the library version,
+ * e.g. 1 in 1.2.3.
+ *
+ * Since: 1.1
+ */
+#define VIRGL_MAJOR_VERSION          (@VIRGL_MAJOR_VERSION@)
+
+/**
+ * VIRGL_MINOR_VERSION:
+ *
+ * Evaluates to the minor version number of the library version,
+ * e.g. 2 in 1.2.3.
+ *
+ * Since: 1.1
+ */
+#define VIRGL_MINOR_VERSION          (@VIRGL_MINOR_VERSION@)
+
+/**
+ * VIRGL_MICRO_VERSION:
+ *
+ * Evaluates to the micro version number of the library version,
+ * e.g. 3 in 1.2.3.
+ *
+ * Since: 1.1
+ */
+#define VIRGL_MICRO_VERSION          (@VIRGL_MICRO_VERSION@)
+
+#define VIRGL_CHECK_VERSION(major,minor,micro) \
+  (VIRGL_MAJOR_VERSION > (major) || \
+   VIRGL_MAJOR_VERSION == (major) && VIRGL_MINOR_VERSION > (minor) || \
+   VIRGL_MAJOR_VERSION == (major) && VIRGL_MINOR_VERSION == (minor) && VIRGL_MICRO_VERSION >= (micro))
+
+#endif /* VIRGL_VERSION_H */
--- a/src/virglrenderer.c	2023-06-29 20:46:58
+++ b/src/virglrenderer.c	2025-12-12 12:05:51
@@ -42,14 +42,19 @@
 #include "util/u_math.h"
 #include "vkr_allocator.h"
 #include "drm_renderer.h"
-#include "vrend_renderer.h"
 #include "proxy/proxy_renderer.h"
-#include "vrend_winsys.h"
+#include "vrend/vrend_renderer.h"
+#include "vrend/vrend_winsys.h"
 
+#ifndef WIN32
+#include "util/libsync.h"
+#endif
+
 #include "virglrenderer.h"
-#include "virglrenderer_hw.h"
+#include "virtgpu_drm.h"
 
 #include "virgl_context.h"
+#include "virgl_fence.h"
 #include "virgl_resource.h"
 #include "virgl_util.h"
 
@@ -66,6 +71,7 @@
    bool proxy_initialized;
    bool external_winsys_initialized;
    bool drm_initialized;
+   bool fence_initialized;
 };
 
 static struct global_state state;
@@ -79,14 +85,18 @@
    struct virgl_resource *res;
    struct pipe_resource *pipe_res;
    struct vrend_renderer_resource_create_args vrend_args =  { 0 };
+   uint32_t map_info;
 
-   if (!state.vrend_initialized)
+   if (!state.vrend_initialized && !state.drm_initialized)
       return EINVAL;
 
    /* do not accept handle 0 */
    if (args->handle == 0)
       return EINVAL;
 
+   if (virgl_resource_lookup(args->handle))
+      return -EINVAL;
+
    vrend_args.target = args->target;
    vrend_args.format = args->format;
    vrend_args.bind = args->bind;
@@ -102,13 +112,12 @@
    if (!pipe_res)
       return EINVAL;
 
+   map_info = vrend_renderer_resource_get_map_info(pipe_res);
    res = virgl_resource_create_from_pipe(args->handle, pipe_res, iov, num_iovs);
-   if (!res) {
-      vrend_renderer_resource_destroy((struct vrend_resource *)pipe_res);
+   if (!res)
       return -ENOMEM;
-   }
 
-   res->map_info = vrend_renderer_resource_get_map_info(pipe_res);
+   res->map_info = map_info;
 
    return 0;
 }
@@ -169,17 +178,43 @@
 void virgl_renderer_fill_caps(uint32_t set, uint32_t version,
                               void *caps)
 {
+   if (getenv("VIRGL_DEBUG_CAPS")) {
+      fprintf(stderr, "DEBUG virgl_renderer_fill_caps: set=%u version=%u\n", set, version);
+      fflush(stderr);
+   }
+   
    switch (set) {
-   case VIRGL_RENDERER_CAPSET_VIRGL:
-   case VIRGL_RENDERER_CAPSET_VIRGL2:
-      if (state.vrend_initialized)
+   case VIRTGPU_DRM_CAPSET_VIRGL:
+   case VIRTGPU_DRM_CAPSET_VIRGL2:
+      if (state.vrend_initialized) {
          vrend_renderer_fill_caps(set, version, (union virgl_caps *)caps);
+         if (getenv("VIRGL_DEBUG_CAPS")) {
+            union virgl_caps *vcaps = (union virgl_caps *)caps;
+            fprintf(stderr, "DEBUG virgl_renderer_fill_caps returning to QEMU:\n");
+            fprintf(stderr, "  max_version=%u\n", vcaps->max_version);
+            fprintf(stderr, "  v1.glsl_level=%u at address %p\n", vcaps->v1.glsl_level, (void*)&vcaps->v1.glsl_level);
+            fprintf(stderr, "  v2.v1.glsl_level=%u at address %p\n", vcaps->v2.v1.glsl_level, (void*)&vcaps->v2.v1.glsl_level);
+            fprintf(stderr, "  caps base address=%p\n", (void*)caps);
+            
+            /* Calculate actual offset */
+            size_t glsl_offset = (uint8_t*)&vcaps->v1.glsl_level - (uint8_t*)caps;
+            fprintf(stderr, "  glsl_level offset from caps base: %zu bytes\n", glsl_offset);
+            
+            /* Dump bytes at that offset */
+            uint8_t *bytes = (uint8_t *)caps;
+            fprintf(stderr, "  Bytes at glsl_level offset (%zu-%zu): ", glsl_offset, glsl_offset+7);
+            for (size_t i = glsl_offset; i < glsl_offset + 8 && i < 1024; i++) 
+               fprintf(stderr, "%02x ", bytes[i]);
+            fprintf(stderr, "\n");
+            fflush(stderr);
+         }
+      }
       break;
-   case VIRGL_RENDERER_CAPSET_VENUS:
+   case VIRTGPU_DRM_CAPSET_VENUS:
       if (state.proxy_initialized)
          proxy_get_capset(set, caps);
       break;
-   case VIRGL_RENDERER_CAPSET_DRM:
+   case VIRTGPU_DRM_CAPSET_DRM:
       if (state.drm_initialized)
          drm_renderer_capset(caps);
       break;
@@ -203,8 +238,7 @@
                                              uint32_t nlen,
                                              const char *name)
 {
-   const enum virgl_renderer_capset capset_id =
-      ctx_flags & VIRGL_RENDERER_CONTEXT_FLAG_CAPSET_ID_MASK;
+   uint32_t capset_id = ctx_flags & VIRGL_RENDERER_CONTEXT_FLAG_CAPSET_ID_MASK;
    struct virgl_context *ctx;
    int ret;
 
@@ -224,18 +258,18 @@
    }
 
    switch (capset_id) {
-   case VIRGL_RENDERER_CAPSET_VIRGL:
-   case VIRGL_RENDERER_CAPSET_VIRGL2:
+   case VIRTGPU_DRM_CAPSET_VIRGL:
+   case VIRTGPU_DRM_CAPSET_VIRGL2:
       if (!state.vrend_initialized)
          return EINVAL;
       ctx = vrend_renderer_context_create(ctx_id, nlen, name);
       break;
-   case VIRGL_RENDERER_CAPSET_VENUS:
+   case VIRTGPU_DRM_CAPSET_VENUS:
       if (!state.proxy_initialized)
          return EINVAL;
       ctx = proxy_context_create(ctx_id, ctx_flags, nlen, name);
       break;
-   case VIRGL_RENDERER_CAPSET_DRM:
+   case VIRTGPU_DRM_CAPSET_DRM:
       if (!state.drm_initialized)
          return EINVAL;
       ctx = drm_renderer_create(nlen, name);
@@ -248,6 +282,7 @@
       return ENOMEM;
 
    ctx->ctx_id = ctx_id;
+   ctx->in_fence_fd = -1;
    ctx->capset_id = capset_id;
    ctx->fence_retire = per_context_fence_retire;
 
@@ -263,7 +298,7 @@
 int virgl_renderer_context_create(uint32_t handle, uint32_t nlen, const char *name)
 {
    return virgl_renderer_context_create_with_flags(handle,
-                                                   VIRGL_RENDERER_CAPSET_VIRGL2,
+                                                   VIRTGPU_DRM_CAPSET_VIRGL2,
                                                    nlen,
                                                    name);
 }
@@ -286,7 +321,10 @@
    if (ndw < 0 || (unsigned)ndw > UINT32_MAX / sizeof(uint32_t))
       return EINVAL;
 
-   return ctx->submit_cmd(ctx, buffer, ndw * sizeof(uint32_t));
+   if (((uintptr_t)buffer & 3) != 0)
+      return EFAULT;
+
+   return ctx->submit_cmd(ctx, buffer, (uint32_t)ndw * sizeof(uint32_t));
 }
 
 int virgl_renderer_transfer_write_iov(uint32_t handle,
@@ -422,6 +460,7 @@
 
 void virgl_renderer_context_poll(uint32_t ctx_id)
 {
+   TRACE_FUNC();
    struct virgl_context *ctx = virgl_context_lookup(ctx_id);
    if (!ctx)
       return;
@@ -482,7 +521,7 @@
    info->fd = res->fd;
 
    if (!res->pipe_resource)
-	   return 0;
+      return 0;
 
    vrend_renderer_resource_get_info(res->pipe_resource,
                                     (struct vrend_renderer_resource_info *)info);
@@ -540,7 +579,26 @@
 
    return 0;
 }
+
+int virgl_renderer_borrow_texture_for_scanout(int res_handle,
+                                              struct virgl_renderer_resource_info_ext *info)
+{
+   TRACE_FUNC();
+   struct virgl_resource *res = virgl_resource_lookup(res_handle);
 
+   if (!res)
+      return EINVAL;
+   if (!info)
+      return EINVAL;
+
+   if (!res->pipe_resource)
+      return 0;
+
+   vrend_renderer_borrow_texture_for_scanout(res->pipe_resource);
+
+   return virgl_renderer_resource_get_info_ext(res_handle, info);
+}
+
 void virgl_renderer_get_cap_set(uint32_t cap_set, uint32_t *max_ver,
                                 uint32_t *max_size)
 {
@@ -548,15 +606,15 @@
 
    /* this may be called before virgl_renderer_init */
    switch (cap_set) {
-   case VIRGL_RENDERER_CAPSET_VIRGL:
-   case VIRGL_RENDERER_CAPSET_VIRGL2:
+   case VIRTGPU_DRM_CAPSET_VIRGL:
+   case VIRTGPU_DRM_CAPSET_VIRGL2:
       vrend_renderer_get_cap_set(cap_set, max_ver, max_size);
       break;
-   case VIRGL_RENDERER_CAPSET_VENUS:
+   case VIRTGPU_DRM_CAPSET_VENUS:
       *max_ver = 0;
       *max_size = proxy_get_capset(cap_set, NULL);
       break;
-   case VIRGL_RENDERER_CAPSET_DRM:
+   case VIRTGPU_DRM_CAPSET_DRM:
       *max_ver = 0;
       *max_size = drm_renderer_capset(NULL);
       break;
@@ -595,8 +653,9 @@
    if (state.winsys_initialized)
       return vrend_winsys_create_context(param);
 
-   vparam.version = 1;
+   vparam.version = 2;
    vparam.shared = param->shared;
+   vparam.compat_ctx = param->compat_ctx;
    vparam.major_ver = param->major_ver;
    vparam.minor_ver = param->minor_ver;
    return state.cbs->create_gl_context(state.cookie, scanout_idx, &vparam);
@@ -621,7 +680,7 @@
 
    ret = state.cbs->make_current(state.cookie, 0, ctx);
    if (ret && state.cbs->version >= 4) {
-      vrend_printf("%s: Error switching context: %d\n", __func__, ret);
+      virgl_error("%s: Error switching context: %d\n", __func__, ret);
       assert(!ret && "Failed to switch GL context");
       return -1;
    }
@@ -636,10 +695,11 @@
    if (state.winsys_initialized || state.external_winsys_initialized)
       return vrend_winsys_create_context(param);
 
-   vparam.version = 1;
+   vparam.version = 2;
    vparam.shared = param->shared;
    vparam.major_ver = param->major_ver;
    vparam.minor_ver = param->minor_ver;
+   vparam.compat_ctx = param->compat_ctx;
    return state.cbs->create_gl_context(state.cookie, scanout_idx, &vparam);
 }
 
@@ -662,8 +722,8 @@
 
    ret = state.cbs->make_current(state.cookie, 0, ctx);
    if (ret && state.cbs->version >= 4) {
-      vrend_printf("%s: Error switching surfaceless context: %d\n",
-                   __func__, ret);
+      virgl_error("%s: Error switching surfaceless context: %d\n",
+                  __func__, ret);
       assert(!ret && "Failed to switch GL context");
       return -1;
    }
@@ -720,8 +780,8 @@
                                     UNUSED void* data)
 {
    /* vrend contexts are polled explicitly by the caller */
-   if (ctx->capset_id != VIRGL_RENDERER_CAPSET_VIRGL &&
-       ctx->capset_id != VIRGL_RENDERER_CAPSET_VIRGL2 &&
+   if (ctx->capset_id != VIRTGPU_DRM_CAPSET_VIRGL &&
+       ctx->capset_id != VIRTGPU_DRM_CAPSET_VIRGL2 &&
        !(state.flags & VIRGL_RENDERER_ASYNC_FENCE_CB))
    {
       assert(ctx->retire_fences);
@@ -759,6 +819,9 @@
    if (state.vrend_initialized)
       vrend_renderer_fini();
 
+   if (state.fence_initialized)
+      virgl_fence_table_cleanup();
+
    if (state.winsys_initialized || state.external_winsys_initialized)
       vrend_winsys_cleanup();
 
@@ -784,14 +847,18 @@
 
    if (state.client_initialized && (state.cookie != cookie ||
                                     state.flags != flags ||
-                                    state.cbs != cbs))
+                                    state.cbs != cbs)) {
+      virgl_error("renderer already initialized");
       return -EBUSY;
+   }
 
    if (!state.client_initialized) {
       if (!cbs ||
           cbs->version < 1 ||
-          cbs->version > VIRGL_RENDERER_CALLBACKS_VERSION)
+          cbs->version > VIRGL_RENDERER_CALLBACKS_VERSION) {
+         virgl_error("invalid renderer callbacks");
          return -1;
+      }
 
       state.cookie = cookie;
       state.flags = flags;
@@ -805,15 +872,19 @@
          vrend_renderer_get_pipe_callbacks();
 
       ret = virgl_resource_table_init(pipe_cbs);
-      if (ret)
+      if (ret) {
+         virgl_error("failed to initialize virgl resources");
          goto fail;
+      }
       state.resource_initialized = true;
    }
 
    if (!state.context_initialized) {
       ret = virgl_context_table_init();
-      if (ret)
+      if (ret) {
+         virgl_error("failed to initialize virgl context");
          goto fail;
+      }
       state.context_initialized = true;
    }
 
@@ -830,6 +901,7 @@
       if (ret) {
          if (drm_fd >= 0)
             close(drm_fd);
+         virgl_error("failed to initialize vrend winsys");
          goto fail;
       }
       state.winsys_initialized = true;
@@ -841,6 +913,7 @@
 
       if (!cbs->create_gl_context || !cbs->destroy_gl_context ||
           !cbs->make_current) {
+         virgl_error("invalid renderer gl callbacks");
          ret = EINVAL;
          goto fail;
       }
@@ -848,12 +921,14 @@
       egl_display = state.cbs->get_egl_display(cookie);
 
       if (!egl_display) {
+         virgl_error("failed to get egl display");
          ret = -1;
          goto fail;
       }
       ret = vrend_winsys_init_external(egl_display);
 
       if (ret) {
+         virgl_error("failed to initialize vrend winsys");
          ret = -1;
          goto fail;
       }
@@ -865,6 +940,7 @@
       uint32_t renderer_flags = 0;
 
       if (!cookie || !cbs) {
+         virgl_error("invalid renderer vrend callbacks");
          ret = -1;
          goto fail;
       }
@@ -879,17 +955,25 @@
          renderer_flags |= VREND_USE_VIDEO;
       if (flags & VIRGL_RENDERER_D3D11_SHARE_TEXTURE)
          renderer_flags |= VREND_D3D11_SHARE_TEXTURE;
+      if (flags & VIRGL_RENDERER_COMPAT_PROFILE)
+         renderer_flags |= VREND_USE_COMPAT_CONTEXT;
+      if (flags & VIRGL_RENDERER_USE_GLES)
+         renderer_flags |= VREND_USE_GLES;
 
       ret = vrend_renderer_init(&vrend_cbs, renderer_flags);
-      if (ret)
+      if (ret) {
+         virgl_error("failed to initialize vrend renderer");
          goto fail;
+      }
       state.vrend_initialized = true;
    }
 
    if (!state.proxy_initialized && (flags & VIRGL_RENDERER_RENDER_SERVER)) {
       ret = proxy_renderer_init(&proxy_cbs, flags | VIRGL_RENDERER_NO_VIRGL);
-      if (ret)
+      if (ret) {
+         virgl_error("failed to initialize venus renderer");
          goto fail;
+      }
       state.proxy_initialized = true;
    }
 
@@ -901,11 +985,22 @@
          drm_fd = cbs->get_drm_fd(cookie);
 
       ret = drm_renderer_init(drm_fd);
-      if (ret)
+      if (ret) {
+         virgl_error("failed to initialize drm renderer");
          goto fail;
+      }
       state.drm_initialized = true;
    }
 
+   if (!state.fence_initialized) {
+      ret = virgl_fence_table_init();
+      if (ret) {
+         virgl_error("failed to initialize fence table");
+         goto fail;
+      }
+      state.fence_initialized = true;
+   }
+
    return 0;
 
 fail:
@@ -960,11 +1055,52 @@
    return -1;
 }
 
+static
+void virgl_null_logger(UNUSED const char *fmt, UNUSED va_list va)
+{
+}
+
+/* Compatibility layer for the virgl_set_debug_callback function */
+static inline void virgl_legacy_logger_wrapper(virgl_debug_callback_type cb,
+                                               const char *fmt,
+                                               ...)
+{
+   va_list va;
+   va_start(va, fmt);
+   cb(fmt, va);
+   va_end(va);
+}
+
+/* The logger need to be wrapped into a structure to be given as void* */
+struct virgl_legacy_logger_holder {
+   virgl_debug_callback_type logger;
+};
+
+static void virgl_legacy_logger(UNUSED enum virgl_log_level_flags log_level,
+                                const char *message,
+                                void* user_data)
+{
+   struct virgl_legacy_logger_holder *log_cb = user_data;
+   virgl_legacy_logger_wrapper(log_cb->logger, "%s", message);
+}
+
+static struct virgl_legacy_logger_holder legacy_logger = { virgl_null_logger };
+
 virgl_debug_callback_type virgl_set_debug_callback(virgl_debug_callback_type cb)
 {
-   return virgl_log_set_logger(cb);
+   virgl_debug_callback_type previous_cb = legacy_logger.logger;
+   legacy_logger.logger = cb;
+   virgl_log_set_handler(virgl_legacy_logger, &legacy_logger, NULL);
+   return previous_cb;
 }
 
+void virgl_set_log_callback(virgl_log_callback_type cb,
+                            void* user_data,
+                            virgl_free_data_callback_type free_user_data_cb)
+{
+   virgl_log_set_handler(cb, user_data, free_user_data_cb);
+}
+
 static int virgl_renderer_export_query(void *execute_args, uint32_t execute_size)
 {
    struct virgl_resource *res;
@@ -1114,19 +1250,15 @@
                                           args->iovecs,
                                           args->num_iovs,
                                           &blob.vulkan_info);
-      if (!res) {
-         close(blob.u.fd);
+      if (!res)
          return -ENOMEM;
-      }
    } else {
       res = virgl_resource_create_from_pipe(args->res_handle,
                                             blob.u.pipe_resource,
                                             args->iovecs,
                                             args->num_iovs);
-      if (!res) {
-         vrend_renderer_resource_destroy((struct vrend_resource *)blob.u.pipe_resource);
+      if (!res)
          return -ENOMEM;
-      }
    }
 
    res->map_info = blob.map_info;
@@ -1150,10 +1282,18 @@
       if (!ret)
          res->map_size = map_size;
    } else {
-      switch (res->fd_type) {
+      enum virgl_resource_fd_type fd_type = res->fd_type;
+      enum virgl_resource_fd_type export_fd_type = res->fd_type;
+      int fd = res->fd;
+
+      /* Create a transient dmabuf. */
+      if (fd_type == VIRGL_RESOURCE_OPAQUE_HANDLE)
+         export_fd_type = virgl_resource_export_fd(res, &fd);
+
+      switch (export_fd_type) {
       case VIRGL_RESOURCE_FD_DMABUF:
       case VIRGL_RESOURCE_FD_SHM:
-         map = mmap(NULL, res->map_size, PROT_WRITE | PROT_READ, MAP_SHARED, res->fd, 0);
+         map = mmap(NULL, res->map_size, PROT_WRITE | PROT_READ, MAP_SHARED, fd, 0);
          map_size = res->map_size;
          break;
       case VIRGL_RESOURCE_FD_OPAQUE:
@@ -1166,6 +1306,9 @@
           */
          break;
       }
+
+      if (export_fd_type != fd_type)
+         close(fd);
    }
 
    if (!map || map == MAP_FAILED)
@@ -1191,12 +1334,12 @@
       switch (res->fd_type) {
       case VIRGL_RESOURCE_FD_DMABUF:
       case VIRGL_RESOURCE_FD_SHM:
+      case VIRGL_RESOURCE_OPAQUE_HANDLE:
          ret = munmap(res->mapped, res->map_size);
          break;
       case VIRGL_RESOURCE_FD_OPAQUE:
          ret = vkr_allocator_resource_unmap(res);
          break;
-      case VIRGL_RESOURCE_OPAQUE_HANDLE:
       case VIRGL_RESOURCE_FD_INVALID:
          /* Avoid a default case so that -Wswitch will tell us at compile time
           * if a new virgl resource type is added without being handled here.
@@ -1313,8 +1456,134 @@
 }
 
 int
-virgl_renderer_export_fence(uint32_t client_fence_id, int *fd)
+virgl_renderer_export_fence(uint64_t client_fence_id, int *fd)
 {
    TRACE_FUNC();
-   return vrend_renderer_export_ctx0_fence(client_fence_id, fd);
+
+   /* transfers FD ownership to caller */
+   *fd = virgl_fence_get_fd(client_fence_id);
+   if (*fd >= 0)
+      return 0;
+
+   return -EINVAL;
+}
+
+int virgl_renderer_export_signalled_fence(void)
+{
+   TRACE_FUNC();
+
+   /* transfers FD ownership to caller, returns -1 on failure */
+   return virgl_fence_get_last_signalled_fence_fd();
+}
+
+static int attach_in_fence_fd(struct virgl_context *ctx, int fence_fd)
+{
+   int ret = -EINVAL;
+
+#ifndef WIN32
+   ret = sync_accumulate("virglrenderer", &ctx->in_fence_fd, fence_fd);
+#endif
+   close(fence_fd);
+
+   return ret;
+}
+
+/* Special entrypoint for vtest, which has received a real fence fd,
+ * not a fence-id
+ */
+int virgl_renderer_attach_fence(int ctx_id, int fence_fd)
+{
+   TRACE_FUNC();
+   struct virgl_context *ctx = virgl_context_lookup(ctx_id);
+   if (!ctx)
+      return EINVAL;
+
+   return attach_in_fence_fd(ctx, fence_fd);
 }
+
+int virgl_renderer_get_fence_fd(uint64_t fence_id)
+{
+   return virgl_fence_get_fd(fence_id);
+}
+
+static int virgl_renderer_context_attach_in_fence(struct virgl_context *ctx,
+                                                  uint64_t fence_id)
+{
+   int ret;
+
+   /*
+    * FD will be -1 in two cases:
+    *
+    *    1. Fence was signalled and retired.
+    *    2. Fence ID is invalid. Virglrenderer doesn't take responsibility
+    *       for handling invalid fences and assumes that all supplied fence
+    *       IDs are always valid. It's caller's responsibility to validate
+    *       fence IDs.
+    */
+   int fd = virgl_fence_get_fd(fence_id);
+   if (fd < 0)
+      return 0;
+
+   ret = attach_in_fence_fd(ctx, fd);
+   if (ret)
+      virgl_error("%s: sync_accumulate failed for fence_id=%" PRIu64 " err=%d\n",
+                  __func__, fence_id, ret);
+
+   return ret;
+}
+
+static int virgl_renderer_context_attach_in_fences(struct virgl_context *ctx,
+                                                   uint64_t *fence_ids,
+                                                   uint32_t num_fences)
+{
+   TRACE_FUNC();
+
+   if (!ctx->supports_fence_sharing)
+      return -EINVAL;
+
+   for (uint32_t i = 0; i < num_fences; i++) {
+      int ret = virgl_renderer_context_attach_in_fence(ctx, fence_ids[i]);
+      if (ret)
+         return ret;
+   }
+
+   return 0;
+}
+
+int virgl_renderer_submit_cmd2(void *buffer,
+                               int ctx_id,
+                               int ndw,
+                               uint64_t *in_fence_ids,
+                               uint32_t num_in_fences)
+{
+   TRACE_FUNC();
+   struct virgl_context *ctx = virgl_context_lookup(ctx_id);
+   if (!ctx)
+      return EINVAL;
+
+   if (((uintptr_t)buffer & 3) != 0)
+      return EFAULT;
+
+   if (ndw < 0 || (unsigned)ndw > UINT32_MAX / sizeof(uint32_t))
+      return EINVAL;
+
+   if (num_in_fences) {
+      int err = virgl_renderer_context_attach_in_fences(ctx, in_fence_ids, num_in_fences);
+      if (err)
+         return err;
+   }
+
+   return ctx->submit_cmd(ctx, buffer, (uint32_t)ndw * sizeof(uint32_t));
+}
+
+int virgl_renderer_get_dev_fd(int ctx_id)
+{
+   struct virgl_context *ctx = virgl_context_lookup(ctx_id);
+   if (!ctx)
+      return -EINVAL;
+
+   if (!ctx->get_device_fd)
+      return -ENODEV;
+
+   return ctx->get_device_fd(ctx);
+}
--- a/src/virglrenderer.h	2023-06-29 20:46:58
+++ b/src/virglrenderer.h	2025-12-11 15:44:12
@@ -31,6 +31,8 @@
 #include <stdbool.h>
 #include <stdarg.h>
 
+#include "virgl-version.h"
+
 struct virgl_box;
 struct iovec;
 
@@ -43,6 +45,7 @@
    bool shared;
    int major_ver;
    int minor_ver;
+   int compat_ctx;
 };
 
 #define VIRGL_RENDERER_CALLBACKS_VERSION 4
@@ -161,7 +164,11 @@
 
 
 #define VIRGL_RENDERER_D3D11_SHARE_TEXTURE (1 << 12)
+#define VIRGL_RENDERER_COMPAT_PROFILE (1 << 13)
 
+/* Blob allocations must be done by guest from dedicated heap (Host visible memory). */
+#define VIRGL_RENDERER_USE_GUEST_VRAM (1 << 14)
+
 VIRGL_EXPORT int virgl_renderer_init(void *cookie, int flags, struct virgl_renderer_callbacks *cb);
 VIRGL_EXPORT void virgl_renderer_poll(void); /* force fences */
 
@@ -251,6 +258,22 @@
 /* new API */
 /* This typedef must be kept in sync with vrend_debug.h */
 typedef void (*virgl_debug_callback_type)(const char *fmt, va_list ap);
+
+enum virgl_log_level_flags {
+   VIRGL_LOG_LEVEL_DEBUG,
+   VIRGL_LOG_LEVEL_INFO,
+   VIRGL_LOG_LEVEL_WARNING,
+   VIRGL_LOG_LEVEL_ERROR,
+
+   /* "SILENT" must be enum with the highest absolute value and it should not
+    * be used as actual log level in calls to virgl_logv and siblings .*/
+   VIRGL_LOG_LEVEL_SILENT,
+};
+
+typedef void (*virgl_free_data_callback_type)(void* user_data);
+typedef void (*virgl_log_callback_type) (enum virgl_log_level_flags log_level,
+                                         const char *message,
+                                         void* user_data);
 
 VIRGL_EXPORT int virgl_renderer_resource_create(struct virgl_renderer_resource_create_args *args, struct iovec *iov, uint32_t num_iovs);
 VIRGL_EXPORT int virgl_renderer_resource_import_eglimage(struct virgl_renderer_resource_create_args *args, void *image);
@@ -262,6 +285,22 @@
 VIRGL_EXPORT int virgl_renderer_context_create(uint32_t handle, uint32_t nlen, const char *name);
 VIRGL_EXPORT void virgl_renderer_context_destroy(uint32_t handle);
 
+/* Submit a command buffer for execution.  ctx_id is the context ID.
+ * ndw is the length of the buffer in 4-byte words.
+ *
+ * The buffer must be at least 4-byte aligned.  Starting in 1.0.2, this
+ * is checked and violations result in EFAULT being returned.  In 1.0.1
+ * and below, a misaligned buffer caused undefined behavior.
+ *
+ * Some renderers require that the buffer is 8-byte aligned.  These
+ * renderers deal with less-aligned buffers by copying the input data.
+ * You can avoid the copy by passing a sufficiently-aligned buffer.
+ *
+ * This function will never mutate the buffer, and is secure against
+ * malicious buffer contents.  However, it is _not_ secure against
+ * concurrent modification of the buffer by other threads while it
+ * is running.
+ */
 VIRGL_EXPORT int virgl_renderer_submit_cmd(void *buffer,
                                            int ctx_id,
                                            int ndw);
@@ -300,7 +339,14 @@
 VIRGL_EXPORT void virgl_renderer_ctx_attach_resource(int ctx_id, int res_handle);
 VIRGL_EXPORT void virgl_renderer_ctx_detach_resource(int ctx_id, int res_handle);
 
+/* This API is deprecated, use virgl_set_log_callback instead */
 VIRGL_EXPORT virgl_debug_callback_type virgl_set_debug_callback(virgl_debug_callback_type cb);
+/* Redirects all the logs to the callback, the callback will be called with the given
+ * user_data, free_user_data_cb will be called if the callback is replaced or if
+ * the program ends to free user_data */
+VIRGL_EXPORT void virgl_set_log_callback(virgl_log_callback_type cb,
+                                         void* user_data,
+                                         virgl_free_data_callback_type free_user_data_cb);
 
 /* return information about a resource */
 
@@ -334,6 +380,9 @@
 VIRGL_EXPORT int virgl_renderer_resource_get_info_ext(int res_handle,
                                                       struct virgl_renderer_resource_info_ext *info);
 
+VIRGL_EXPORT int virgl_renderer_borrow_texture_for_scanout(int res_handle,
+                                                           struct virgl_renderer_resource_info_ext *info);
+
 VIRGL_EXPORT void virgl_renderer_cleanup(void *cookie);
 
 /* reset the rendererer - destroy all contexts and resource */
@@ -411,6 +460,9 @@
                                                      uint32_t ring_idx,
                                                      uint64_t fence_id);
 
+VIRGL_EXPORT void virgl_renderer_context_poll(uint32_t ctx_id); /* force fences */
+VIRGL_EXPORT int virgl_renderer_context_get_poll_fd(uint32_t ctx_id);
+
 /*
  * These are unstable APIs for development only. Use these for development/testing purposes
  * only, not in production
@@ -418,11 +470,42 @@
 #ifdef VIRGL_RENDERER_UNSTABLE_APIS
 
 VIRGL_EXPORT int
-virgl_renderer_export_fence(uint32_t client_fence_id, int *fd);
+virgl_renderer_export_fence(uint64_t client_fence_id, int *fd);
 
-VIRGL_EXPORT void virgl_renderer_context_poll(uint32_t ctx_id); /* force fences */
-VIRGL_EXPORT int virgl_renderer_context_get_poll_fd(uint32_t ctx_id);
+VIRGL_EXPORT int
+virgl_renderer_export_signalled_fence(void);
 
+/* Submit a command buffer for execution.  ctx_id is the context ID.
+ * ndw is the length of the buffer in 4-byte words.
+ *
+ * The buffer must be at least 4-byte aligned.  Starting in 1.0.2, this
+ * is checked and violations result in EFAULT being returned.  In 1.0.1
+ * and below, a misaligned buffer caused undefined behavior.
+ *
+ * Some renderers require that the buffer is 8-byte aligned.  These
+ * renderers deal with less-aligned buffers by copying the input data.
+ * You can avoid the copy by passing a sufficiently-aligned buffer.
+ *
+ * This function will never mutate the buffer, and is secure against
+ * malicious buffer contents.  However, it is _not_ secure against
+ * concurrent modification of the buffer by other threads while it
+ * is running.
+ *
+ * Unlike virgl_renderer_submitt_cmd(), this function allows passing
+ * fences for explicit synchronization.
+ */
+VIRGL_EXPORT int
+virgl_renderer_submit_cmd2(void *buffer,
+                           int ctx_id,
+                           int ndw,
+                           uint64_t *in_fence_ids,
+                           uint32_t num_in_fences);
+
+/* vtest semi-private APIs: */
+VIRGL_EXPORT int virgl_renderer_attach_fence(int ctx_id, int fence_fd);
+VIRGL_EXPORT int virgl_renderer_get_fence_fd(uint64_t fence_id);
+VIRGL_EXPORT int virgl_renderer_get_dev_fd(int ctx_id);
+
 #endif /* VIRGL_RENDERER_UNSTABLE_APIS */
 
 #endif

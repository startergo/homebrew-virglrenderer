diff -Naur --exclude=.git virglrenderer-upstream/server/render_socket.c virglrenderer-manual/server/render_socket.c
--- virglrenderer-upstream/server/render_socket.c	2026-01-09 15:47:29
+++ virglrenderer-manual/server/render_socket.c	2026-01-09 15:47:48
@@ -4,6 +4,7 @@
  */
 
 #include "render_socket.h"
+#include <fcntl.h>
 
 #include <errno.h>
 #include <sys/socket.h>
@@ -28,11 +29,27 @@
 bool
 render_socket_pair(int out_fds[static 2])
 {
+   #if defined(__APPLE__)
+   // macOS doesn't support SOCK_CLOEXEC, manually set FD_CLOEXEC
+   int ret = socketpair(AF_UNIX, SOCK_SEQPACKET, 0, out_fds);
+   if (ret) {
+      render_log("failed to create socket pair");
+      return false;
+   }
+   // Set FD_CLOEXEC on both sockets
+   fcntl(out_fds[0], F_SETFD, FD_CLOEXEC);
+   fcntl(out_fds[1], F_SETFD, FD_CLOEXEC);
+#else
    int ret = socketpair(AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, out_fds);
    if (ret) {
       render_log("failed to create socket pair");
       return false;
    }
+#endif
+   if (ret) {
+      render_log("failed to create socket pair");
+      return false;
+   }
 
    return true;
 }
@@ -80,7 +97,12 @@
 render_socket_recvmsg(struct render_socket *socket, struct msghdr *msg, size_t *out_size)
 {
    do {
-      const ssize_t s = recvmsg(socket->fd, msg, MSG_CMSG_CLOEXEC);
+      #if defined(__APPLE__)
+   // macOS doesn't support MSG_CMSG_CLOEXEC
+   const ssize_t s = recvmsg(socket->fd, msg, 0);
+#else
+   const ssize_t s = recvmsg(socket->fd, msg, MSG_CMSG_CLOEXEC);
+#endif
       if (unlikely(s <= 0)) {
          if (!s)
             return false;
diff -Naur --exclude=.git virglrenderer-upstream/server/render_worker.c virglrenderer-manual/server/render_worker.c
--- virglrenderer-upstream/server/render_worker.c	2026-01-09 15:47:29
+++ virglrenderer-manual/server/render_worker.c	2026-01-09 15:47:48
@@ -24,10 +24,15 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <signal.h>
+#if defined(__APPLE__)
+// macOS doesn't have signalfd, use alternative implementation
+#include <sys/select.h>
+#else
 #include <sys/signalfd.h>
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <threads.h>
+#endif
 #include <unistd.h>
 
 struct minijail;
@@ -182,7 +187,13 @@
       return -1;
    }
 
-   int fd = signalfd(-1, &set, SFD_NONBLOCK | SFD_CLOEXEC);
+#if defined(__APPLE__)
+   // macOS doesn't support signalfd, use -1 to indicate polling mode
+   sigprocmask(SIG_BLOCK, &set, NULL);
+   int fd = -1;
+#else
+      int fd = signalfd(-1, &set, SFD_NONBLOCK | SFD_CLOEXEC);
+#endif
    if (fd < 0) {
       render_log("failed to create signalfd");
       return -1;
@@ -322,6 +333,10 @@
       return true;
 
    do {
+#if defined(__APPLE__)
+      // macOS doesn't have signalfd, just return true
+      return true;
+#else
       struct signalfd_siginfo siginfos[8];
       const ssize_t r = read(jail->sigchld_fd, siginfos, sizeof(siginfos));
       if (r == sizeof(siginfos))
@@ -331,6 +346,7 @@
 
       render_log("failed to read signalfd");
       return false;
+#endif
    } while (true);
 
    return true;
diff -Naur --exclude=.git virglrenderer-upstream/src/proxy/proxy_socket.c virglrenderer-manual/src/proxy/proxy_socket.c
--- virglrenderer-upstream/src/proxy/proxy_socket.c	2026-01-09 15:47:29
+++ virglrenderer-manual/src/proxy/proxy_socket.c	2026-01-09 15:47:48
@@ -100,7 +100,12 @@
 proxy_socket_recvmsg(struct proxy_socket *socket, struct msghdr *msg)
 {
    do {
-      const ssize_t s = recvmsg(socket->fd, msg, MSG_CMSG_CLOEXEC);
+      #if defined(__APPLE__)
+   // macOS doesn't support MSG_CMSG_CLOEXEC
+   const ssize_t s = recvmsg(socket->fd, msg, 0);
+#else
+   const ssize_t s = recvmsg(socket->fd, msg, MSG_CMSG_CLOEXEC);
+#endif
       if (unlikely(s < 0)) {
          if (errno == EAGAIN || errno == EINTR)
             continue;
diff -Naur --exclude=.git virglrenderer-upstream/src/venus/vkr_ring.c virglrenderer-manual/src/venus/vkr_ring.c
--- virglrenderer-upstream/src/venus/vkr_ring.c	2026-01-09 15:47:29
+++ virglrenderer-manual/src/venus/vkr_ring.c	2026-01-09 15:47:48
@@ -13,6 +13,18 @@
 
 #include "vkr_context.h"
 
+#if defined(__APPLE__)
+// macOS doesn't have clock_nanosleep, use nanosleep instead
+static inline int clock_nanosleep(clockid_t clock_id, int flags,
+                                   const struct timespec *request,
+                                   struct timespec *remain)
+{
+   struct timespec req = *request;
+   return nanosleep(&req, remain);
+}
+#endif
+
+
 static inline void *
 get_resource_pointer(const struct vkr_resource *res, size_t offset)
 {
diff -Naur --exclude=.git virglrenderer-upstream/src/virglrenderer.c virglrenderer-manual/src/virglrenderer.c
--- virglrenderer-upstream/src/virglrenderer.c	2026-01-09 15:47:29
+++ virglrenderer-manual/src/virglrenderer.c	2026-01-09 15:47:48
@@ -178,11 +178,37 @@
 void virgl_renderer_fill_caps(uint32_t set, uint32_t version,
                               void *caps)
 {
+   if (getenv("VIRGL_DEBUG_CAPS")) {
+      fprintf(stderr, "DEBUG virgl_renderer_fill_caps: set=%u version=%u\n", set, version);
+      fflush(stderr);
+   }
+   
    switch (set) {
    case VIRTGPU_DRM_CAPSET_VIRGL:
    case VIRTGPU_DRM_CAPSET_VIRGL2:
-      if (state.vrend_initialized)
+      if (state.vrend_initialized) {
          vrend_renderer_fill_caps(set, version, (union virgl_caps *)caps);
+         if (getenv("VIRGL_DEBUG_CAPS")) {
+            union virgl_caps *vcaps = (union virgl_caps *)caps;
+            fprintf(stderr, "DEBUG virgl_renderer_fill_caps returning to QEMU:\n");
+            fprintf(stderr, "  max_version=%u\n", vcaps->max_version);
+            fprintf(stderr, "  v1.glsl_level=%u at address %p\n", vcaps->v1.glsl_level, (void*)&vcaps->v1.glsl_level);
+            fprintf(stderr, "  v2.v1.glsl_level=%u at address %p\n", vcaps->v2.v1.glsl_level, (void*)&vcaps->v2.v1.glsl_level);
+            fprintf(stderr, "  caps base address=%p\n", (void*)caps);
+            
+            /* Calculate actual offset */
+            size_t glsl_offset = (uint8_t*)&vcaps->v1.glsl_level - (uint8_t*)caps;
+            fprintf(stderr, "  glsl_level offset from caps base: %zu bytes\n", glsl_offset);
+            
+            /* Dump bytes at that offset */
+            uint8_t *bytes = (uint8_t *)caps;
+            fprintf(stderr, "  Bytes at glsl_level offset (%zu-%zu): ", glsl_offset, glsl_offset+7);
+            for (size_t i = glsl_offset; i < glsl_offset + 8 && i < 1024; i++) 
+               fprintf(stderr, "%02x ", bytes[i]);
+            fprintf(stderr, "\n");
+            fflush(stderr);
+         }
+      }
       break;
    case VIRTGPU_DRM_CAPSET_VENUS:
       if (state.proxy_initialized)
@@ -555,6 +581,25 @@
    }
 
    return 0;
+}
+
+int virgl_renderer_borrow_texture_for_scanout(int res_handle,
+                                              struct virgl_renderer_resource_info_ext *info)
+{
+   TRACE_FUNC();
+   struct virgl_resource *res = virgl_resource_lookup(res_handle);
+
+   if (!res)
+      return EINVAL;
+   if (!info)
+      return EINVAL;
+
+   if (!res->pipe_resource)
+      return 0;
+
+   vrend_renderer_borrow_texture_for_scanout(res->pipe_resource);
+
+   return virgl_renderer_resource_get_info_ext(res_handle, info);
 }
 
 void virgl_renderer_get_cap_set(uint32_t cap_set, uint32_t *max_ver,
diff -Naur --exclude=.git virglrenderer-upstream/src/virglrenderer.h virglrenderer-manual/src/virglrenderer.h
--- virglrenderer-upstream/src/virglrenderer.h	2026-01-09 15:47:29
+++ virglrenderer-manual/src/virglrenderer.h	2026-01-09 15:47:48
@@ -380,6 +380,9 @@
 VIRGL_EXPORT int virgl_renderer_resource_get_info_ext(int res_handle,
                                                       struct virgl_renderer_resource_info_ext *info);
 
+VIRGL_EXPORT int virgl_renderer_borrow_texture_for_scanout(int res_handle,
+                                                           struct virgl_renderer_resource_info_ext *info);
+
 VIRGL_EXPORT void virgl_renderer_cleanup(void *cookie);
 
 /* reset the rendererer - destroy all contexts and resource */
diff -Naur --exclude=.git virglrenderer-upstream/src/vrend/vrend_blitter.h virglrenderer-manual/src/vrend/vrend_blitter.h
--- virglrenderer-upstream/src/vrend/vrend_blitter.h	2026-01-09 15:47:29
+++ virglrenderer-manual/src/vrend/vrend_blitter.h	2026-01-09 15:47:48
@@ -35,6 +35,12 @@
    "%s"                                         \
 
 #define FS_HEADER_GLES                             \
+   "#version 300 es\n"                          \
+   "// Blitter\n"                               \
+   "%s"                                         \
+   "precision mediump float;\n"                 \
+
+#define FS_HEADER_GLES_MS                       \
    "#version 310 es\n"                          \
    "// Blitter\n"                               \
    "%s"                                         \
@@ -52,6 +58,11 @@
    "// Blitter\n"                               \
 
 #define HEADER_GLES                             \
+   "#version 300 es\n"                          \
+   "// Blitter\n"                               \
+   "precision mediump float;\n"                 \
+
+#define HEADER_GLES_MS                          \
    "#version 310 es\n"                          \
    "// Blitter\n"                               \
    "precision mediump float;\n"                 \
@@ -145,7 +156,7 @@
    "}\n"
 
 #define FS_TEXFETCH_COL_MSAA_GL FS_HEADER_GL FS_TEXFETCH_COL_MSAA_BODY
-#define FS_TEXFETCH_COL_MSAA_GLES FS_HEADER_GLES FS_TEXFETCH_COL_MSAA_BODY
+#define FS_TEXFETCH_COL_MSAA_GLES FS_HEADER_GLES_MS FS_TEXFETCH_COL_MSAA_BODY
 #define FS_TEXFETCH_COL_MSAA_ARRAY_GLES FS_HEADER_GLES_MS_ARRAY FS_TEXFETCH_COL_MSAA_BODY
 
 #define FS_TEXFETCH_DS_BODY                             \
@@ -178,7 +189,7 @@
 struct vrend_resource;
 struct vrend_blit_info;
 #define FS_TEXFETCH_DS_MSAA_GL HEADER_GL FS_TEXFETCH_DS_MSAA_BODY
-#define FS_TEXFETCH_DS_MSAA_GLES HEADER_GLES FS_TEXFETCH_DS_MSAA_BODY_GLES
+#define FS_TEXFETCH_DS_MSAA_GLES HEADER_GLES_MS FS_TEXFETCH_DS_MSAA_BODY_GLES
 #define FS_TEXFETCH_DS_MSAA_ARRAY_GLES HEADER_GLES_MS_ARRAY FS_TEXFETCH_DS_MSAA_BODY_GLES
 
 /* implement blitting using OpenGL. */
diff -Naur --exclude=.git virglrenderer-upstream/src/vrend/vrend_decode.c virglrenderer-manual/src/vrend/vrend_decode.c
--- virglrenderer-upstream/src/vrend/vrend_decode.c	2026-01-09 15:47:29
+++ virglrenderer-manual/src/vrend/vrend_decode.c	2026-01-09 15:47:48
@@ -888,6 +888,17 @@
       return EINVAL;
    }
 
+   /* Surface GL errors with object metadata to pinpoint bad creations. */
+   if (!vrend_check_no_error(ctx) && ret == 0) {
+      virgl_error("GL error during CREATE_OBJECT type=%s handle=0x%x len=%u\n",
+                  vrend_get_object_type_name(obj_type), handle, length);
+      /* Dump a small slice of the payload for quick diagnosis. */
+      for (uint32_t i = 0; i < length && i < 12; i++) {
+         virgl_error("  dword[%u]=0x%x\n", i, buf[i]);
+      }
+      ret = EINVAL;
+   }
+
    return ret;
 }
 
@@ -2095,9 +2106,22 @@
 
       TRACE_SCOPE_SLOW(vrend_get_comand_name(cmd));
 
+      /* If video is disabled at runtime, drop video commands quietly to avoid
+       * noisy errors from guest probes (e.g., gst-plugin-scan).
+       */
+      if (!vrend_renderer_video_available() &&
+          cmd >= VIRGL_CCMD_CREATE_VIDEO_CODEC && cmd <= VIRGL_CCMD_END_FRAME) {
+         continue;
+      }
+
       ret = decode_table[cmd](gdctx->grctx, buf, len);
-      if (!vrend_check_no_error(gdctx->grctx) && !ret)
+      if (!vrend_check_no_error(gdctx->grctx) && !ret) {
+         /* Surface the offending command when a GL error is observed. */
+         virgl_error("GL error after %s (ctx %d cmd=0x%x len=%u offset=%u)\n",
+                     vrend_get_comand_name(cmd), gdctx->base.ctx_id,
+                     cmd, len, cur_offset);
          ret = EINVAL;
+      }
       if (ret) {
          virgl_error("context %d failed to dispatch %s: %d\n",
                gdctx->base.ctx_id, vrend_get_comand_name(cmd), ret);
diff -Naur --exclude=.git virglrenderer-upstream/src/vrend/vrend_formats.c virglrenderer-manual/src/vrend/vrend_formats.c
--- virglrenderer-upstream/src/vrend/vrend_formats.c	2026-01-09 15:47:29
+++ virglrenderer-manual/src/vrend/vrend_formats.c	2026-01-09 15:47:48
@@ -716,48 +716,183 @@
    assert(glGetError() == GL_NO_ERROR &&
           "Stale error state detected, please check for failures in initialization");
 
+   /* glTexStorage2DMultisample availability check with graceful downgrade:
+    * 
+    * glTexStorage2DMultisample requires:
+    *   - OpenGL 4.3+ or GL_ARB_texture_storage_multisample (desktop GL)
+    *   - OpenGL ES 3.1+ (mobile/ANGLE)
+    * 
+    * Fallback alternatives available on older versions:
+    *   - glTexImage2DMultisample: GL 3.2+ / ES 3.1+ (works on GL 4.1 Core)
+    *   - glRenderbufferStorageMultisample: GL 3.0+ / ES 3.0+ (works on ANGLE)
+    * 
+    * We'll use glTexStorage2DMultisample if available, otherwise fall back to
+    * glTexImage2DMultisample for proper MSAA capability testing. */
+   
+   const char *renderer = (const char *)glGetString(GL_RENDERER);
+   const char *version_str = (const char *)glGetString(GL_VERSION);
+   
+   /* Check multisample function availability with multiple fallback options */
+   bool has_tex_storage_ms = false;
+   bool has_tex_image_ms = false;
+   bool has_rbo_storage_ms = false;
+   
+   if (epoxy_is_desktop_gl()) {
+      /* Desktop OpenGL path */
+      if (epoxy_gl_version() >= 43) {
+         has_tex_storage_ms = true;
+      } else if (epoxy_has_gl_extension("GL_ARB_texture_storage_multisample")) {
+         has_tex_storage_ms = true;
+      }
+      /* glTexImage2DMultisample available since GL 3.2 */
+      if (epoxy_gl_version() >= 32) {
+         has_tex_image_ms = true;
+      }
+      /* glRenderbufferStorageMultisample available since GL 3.0 */
+      if (epoxy_gl_version() >= 30) {
+         has_rbo_storage_ms = true;
+      }
+   } else {
+      /* OpenGL ES path */
+      if (epoxy_gl_version() >= 31) {
+         has_tex_storage_ms = true;
+         has_tex_image_ms = true;
+      }
+      /* glRenderbufferStorageMultisample available since ES 3.0 (ANGLE/Metal) */
+      if (epoxy_gl_version() >= 30) {
+         has_rbo_storage_ms = true;
+      }
+   }
+   
+   /* If no multisample functions available at all, disable MSAA */
+   if (!has_tex_storage_ms && !has_tex_image_ms && !has_rbo_storage_ms) {
+      fprintf(stderr, "[VREND FORMATS] No multisample functions available "
+                      "(GL version: %s, renderer: %s, is_desktop: %d). "
+                      "Disabling MSAA support.\n", 
+                      version_str ? version_str : "unknown",
+                      renderer ? renderer : "unknown",
+                      epoxy_is_desktop_gl());
+      memset(caps->sample_locations, 0, 8 * sizeof(uint32_t));
+      return 0;  /* Return 0 to indicate MSAA not supported */
+   }
+   
+   /* Log which multisample method we're using */
+   if (has_tex_storage_ms) {
+      fprintf(stderr, "[VREND FORMATS] Testing MSAA with glTexStorage2DMultisample\n");
+   } else if (has_tex_image_ms) {
+      fprintf(stderr, "[VREND FORMATS] Testing MSAA with glTexImage2DMultisample fallback\n");
+   } else if (has_rbo_storage_ms) {
+      fprintf(stderr, "[VREND FORMATS] Testing MSAA with glRenderbufferStorageMultisample fallback "
+                      "(GL version: %s, renderer: %s)\n",
+                      version_str ? version_str : "unknown",
+                      renderer ? renderer : "unknown");
+   }
+
+   fprintf(stderr, "[VREND FORMATS] Starting MSAA capability test with max_samples=%u\n", max_samples);
+   
    glGenFramebuffers( 1, &fbo );
    memset(caps->sample_locations, 0, 8 * sizeof(uint32_t));
 
    for (int i = 3; i >= 0; i--) {
-      if (test_num_samples[i] > max_samples)
+      if (test_num_samples[i] > max_samples) {
+         fprintf(stderr, "[VREND FORMATS] Skipping %u samples (exceeds max %u)\n", 
+                 test_num_samples[i], max_samples);
          continue;
-      glGenTextures(1, &tex);
-      glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, tex);
-      glTexStorage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, test_num_samples[i], GL_RGBA32F, 64, 64, GL_TRUE);
+      }
+      
+      fprintf(stderr, "[VREND FORMATS] Testing %u samples...\n", test_num_samples[i]);
+      
+      /* Clear any stale errors before testing */
+      while (glGetError() != GL_NO_ERROR);
+      
+      if (has_tex_storage_ms || has_tex_image_ms) {
+         /* Texture-based MSAA testing - use GL_RGBA8 for better compatibility */
+         glGenTextures(1, &tex);
+         GLenum err1 = glGetError();
+         
+         glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, tex);
+         GLenum err2 = glGetError();
+         
+         if (has_tex_storage_ms) {
+            glTexStorage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, test_num_samples[i], GL_RGBA8, 64, 64, GL_TRUE);
+         } else {
+            glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, test_num_samples[i], GL_RGBA8, 64, 64, GL_TRUE);
+         }
+         GLenum err3 = glGetError();
+         
+         if (err1 != GL_NO_ERROR || err2 != GL_NO_ERROR || err3 != GL_NO_ERROR) {
+            fprintf(stderr, "[VREND FORMATS]   glGenTextures err=0x%x, glBindTexture err=0x%x, glTex*Multisample err=0x%x\n",
+                    err1, err2, err3);
+         }
+      } else {
+         /* Renderbuffer-based MSAA testing (fallback for ES 3.0 / ANGLE) */
+         GLuint rbo;
+         glGenRenderbuffers(1, &rbo);
+         glBindRenderbuffer(GL_RENDERBUFFER, rbo);
+         glRenderbufferStorageMultisample(GL_RENDERBUFFER, test_num_samples[i], GL_RGBA8, 64, 64);
+         tex = rbo;  /* Store RBO handle in tex variable for cleanup */
+      }
+      
       status = glGetError();
       if (status == GL_NO_ERROR) {
          glBindFramebuffer(GL_FRAMEBUFFER, fbo);
-         glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, tex, 0);
+         
+         if (has_tex_storage_ms || has_tex_image_ms) {
+            glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, tex, 0);
+         } else {
+            /* For renderbuffer fallback */
+            glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, tex);
+         }
+         
          status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
          if (status == GL_FRAMEBUFFER_COMPLETE) {
+            fprintf(stderr, "[VREND FORMATS] ✓ %u samples COMPLETE\n", test_num_samples[i]);
             if (max_samples_confirmed < test_num_samples[i])
                max_samples_confirmed = test_num_samples[i];
 
-            for (unsigned k = 0; k < test_num_samples[i]; ++k) {
-               float msp[2];
-               uint32_t compressed;
-               glGetMultisamplefv(GL_SAMPLE_POSITION, k, msp);
-               compressed = ((unsigned)(floor(msp[0] * 16.0f)) & 0xf) << 4;
-               compressed |= ((unsigned)(floor(msp[1] * 16.0f)) & 0xf);
-               caps->sample_locations[out_buf_offsets[i] + (k >> 2)] |= compressed  << (8 * (k & 3));
+            /* glGetMultisamplefv only available in desktop GL (since 3.2), not in GL ES */
+            if (epoxy_is_desktop_gl()) {
+               for (unsigned k = 0; k < test_num_samples[i]; ++k) {
+                  float msp[2];
+                  uint32_t compressed;
+                  glGetMultisamplefv(GL_SAMPLE_POSITION, k, msp);
+                  compressed = ((unsigned)(floor(msp[0] * 16.0f)) & 0xf) << 4;
+                  compressed |= ((unsigned)(floor(msp[1] * 16.0f)) & 0xf);
+                  caps->sample_locations[out_buf_offsets[i] + (k >> 2)] |= compressed  << (8 * (k & 3));
+               }
+            } else {
+               /* OpenGL ES: sample locations not available, leave them zero-initialized */
+               fprintf(stderr, "[VREND FORMATS]   (OpenGL ES: sample locations not available)\n");
             }
             lowest_working_ms_count_idx = i;
          } else {
+            fprintf(stderr, "[VREND FORMATS] ✗ %u samples INCOMPLETE (status=0x%x)\n", 
+                    test_num_samples[i], status);
             /* If a framebuffer doesn't support low sample counts,
              * use the sample position from the last working larger count. */
             if (lowest_working_ms_count_idx > 0) {
                for (unsigned k = 0; k < test_num_samples[i]; ++k) {
                   caps->sample_locations[out_buf_offsets[i] + (k >> 2)] =
-                        caps->sample_locations[out_buf_offsets[lowest_working_ms_count_idx]  + (k >> 2)];
+                     caps->sample_locations[out_buf_offsets[lowest_working_ms_count_idx]  + (k >> 2)];
                }
             }
          }
          glBindFramebuffer(GL_FRAMEBUFFER, 0);
+      } else {
+         fprintf(stderr, "[VREND FORMATS] ✗ %u samples GL_ERROR=0x%x\n", test_num_samples[i], status);
       }
-      glDeleteTextures(1, &tex);
+      
+      /* Cleanup - delete texture or renderbuffer */
+      if (has_tex_storage_ms || has_tex_image_ms) {
+         glDeleteTextures(1, &tex);
+      } else {
+         glDeleteRenderbuffers(1, &tex);
+      }
    }
    glDeleteFramebuffers(1, &fbo);
+   
+   fprintf(stderr, "[VREND FORMATS] MSAA test complete: returning max_samples_confirmed=%u\n", 
+           max_samples_confirmed);
    return max_samples_confirmed;
 }
 
--- virglrenderer-main/src/vrend/vrend_renderer.c	2026-01-01 08:05:29
+++ virglrenderer-test-patch/virglrenderer-main/src/vrend/vrend_renderer.c	2026-01-09 23:05:21
@@ -1390,12 +1390,85 @@
    GLint param;
    const char *shader_parts[SHADER_MAX_STRINGS];
 
-   for (int i = 0; i < shader->glsl_strings.num_strings; i++)
-      shader_parts[i] = shader->glsl_strings.strings[i].buf;
+   char *modified_shaders[SHADER_MAX_STRINGS] = {NULL};
 
+   /* GL_EXT_shader_texture_lod is a GLES extension that Firefox may require.
+    * In desktop GL core profile, this functionality is available as core (since GLSL 1.30).
+    * For core profile: Remove the extension directive entirely. */
+   for (int i = 0; i < shader->glsl_strings.num_strings; i++) {
+      const char *src = shader->glsl_strings.strings[i].buf;
+      const char *ext_check = strstr(src, "GL_EXT_shader_texture_lod");
+   
+      if (ext_check) {
+         /* Found GL_EXT_shader_texture_lod - verify it's an #extension directive */
+         const char *line_start = ext_check;
+         while (line_start > src && *(line_start - 1) != '\n')
+            line_start--;
+   
+         if (strncmp(line_start, "#extension", 9) == 0) {
+            /* This is an extension directive - remove it entirely */
+            size_t src_len = strlen(src);
+            char *modified = malloc(src_len + 1);
+            if (modified) {
+               char *dst = modified;
+               const char *read_pos = src;
+   
+               while ((ext_check = strstr(read_pos, "GL_EXT_shader_texture_lod")) != NULL) {
+                  /* Verify it's actually an #extension directive */
+                  line_start = ext_check;
+                  while (line_start > read_pos && *(line_start - 1) != '\n')
+                     line_start--;
+   
+                  if (strncmp(line_start, "#extension", 9) != 0) {
+                     /* Not an extension directive, just copy past it */
+                     size_t copy_len = ext_check + 25 - read_pos;
+                     memcpy(dst, read_pos, copy_len);
+                     dst += copy_len;
+                     read_pos = ext_check + 25;
+                     continue;
+                  }
+   
+                  /* Find the end of the line */
+                  const char *line_end = strchr(ext_check, '\n');
+                  if (!line_end)
+                     line_end = read_pos + strlen(read_pos);
+   
+                  /* Copy up to the extension directive */
+                  size_t prefix_len = line_start - read_pos;
+                  memcpy(dst, read_pos, prefix_len);
+                  dst += prefix_len;
+   
+                  /* Skip the entire extension directive line */
+                  read_pos = line_end;
+                  if (*read_pos == '\n')
+                     read_pos++; /* Skip the newline too */
+               }
+   
+               /* Copy remaining string */
+               strcpy(dst, read_pos);
+               shader_parts[i] = modified;
+               modified_shaders[i] = modified;
+            } else {
+               shader_parts[i] = src;
+            }
+         } else {
+            /* Contains extension name but not in #extension directive */
+            shader_parts[i] = src;
+         }
+      } else {
+         shader_parts[i] = src;
+      }
+   }
+
    shader->id = glCreateShader(conv_shader_type(shader->sel->type));
    glShaderSource(shader->id, shader->glsl_strings.num_strings, shader_parts, NULL);
    glCompileShader(shader->id);
+
+   /* Free temporary modified shader strings after compilation */
+   for (int i = 0; i < shader->glsl_strings.num_strings; i++) {
+      if (modified_shaders[i])
+         free(modified_shaders[i]);
+   }
    glGetShaderiv(shader->id, GL_COMPILE_STATUS, &param);
    if (param == GL_FALSE) {
       char infolog[65536];
diff -Naur --exclude=.git virglrenderer-upstream/src/vrend/vrend_renderer.h virglrenderer-manual/src/vrend/vrend_renderer.h
--- virglrenderer-upstream/src/vrend/vrend_renderer.h	2026-01-09 15:47:29
+++ virglrenderer-manual/src/vrend/vrend_renderer.h	2026-01-09 15:47:48
@@ -564,6 +564,8 @@
 void vrend_renderer_resource_get_info(struct pipe_resource *pres,
                                       struct vrend_renderer_resource_info *info);
 
+void vrend_renderer_borrow_texture_for_scanout(struct pipe_resource *pres);
+
 void vrend_renderer_get_cap_set(uint32_t cap_set, uint32_t *max_ver,
                                 uint32_t *max_size);
 
@@ -611,6 +613,8 @@
                                                  {3,3}, {3,2}, {3,1}, {3,0} };
 
 extern const struct vrend_if_cbs *vrend_clicbs;
+
+bool vrend_renderer_video_available(void);
 
 int vrend_renderer_export_query(struct pipe_resource *pres,
                                 struct virgl_renderer_export_query *export_query);
diff -Naur --exclude=.git virglrenderer-upstream/src/vrend/vrend_shader.c virglrenderer-manual/src/vrend/vrend_shader.c
--- virglrenderer-upstream/src/vrend/vrend_shader.c	2026-01-09 15:47:29
+++ virglrenderer-manual/src/vrend/vrend_shader.c	2026-01-09 15:48:07
@@ -6301,10 +6301,26 @@
 
       if (ctx->prog_type == TGSI_PROCESSOR_VERTEX && ctx->cfg->use_explicit_locations)
          emit_ext(glsl_strbufs, "ARB_explicit_attrib_location", "require");
-      if (ctx->prog_type == TGSI_PROCESSOR_FRAGMENT && fs_emit_layout(ctx))
-         emit_ext(glsl_strbufs, "ARB_fragment_coord_conventions", "require");
 
-      if (ctx->ubo_used_mask)
+      /* Fragment coord conventions:
+       * - Core in GLSL 1.50+ (layout qualifier support)
+       * - Extension ARB_fragment_coord_conventions for older GLSL
+       * - macOS core GL 4.1 reports the capability but NOT the extension string
+       * - Check capability bit instead of extension string for GLSL < 150
+       */
+      if (ctx->prog_type == TGSI_PROCESSOR_FRAGMENT && fs_emit_layout(ctx)) {
+         if (ctx->glsl_ver_required < 150) {
+            /* For GLSL < 150, only require extension if not in core profile
+             * (i.e., capability was set via extension string, not GL 3.2+ core) */
+            if (!ctx->cfg->use_core_profile) {
+               emit_ext(glsl_strbufs, "ARB_fragment_coord_conventions", "require");
+            }
+         }
+         /* For GLSL >= 150, the extension is core - no need to require it */
+      }
+
+      /* Uniform buffers are core in GLSL 1.40+; only request the ARB extension when targeting older versions. */
+      if (ctx->ubo_used_mask && ctx->glsl_ver_required < 140)
          emit_ext(glsl_strbufs, "ARB_uniform_buffer_object", "require");
 
       if (ctx->num_cull_dist_prop || ctx->key->num_in_cull || ctx->key->num_out_cull)

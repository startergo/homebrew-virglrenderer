diff --git a/src/vrend/vrend_renderer.c b/src/vrend/vrend_renderer.c
index 1dbe026..b6adf39 100644
--- a/src/vrend/vrend_renderer.c
+++ b/src/vrend/vrend_renderer.c
@@ -3187,12 +3187,35 @@ static void vrend_hw_emit_framebuffer_state(struct vrend_sub_context *sub_ctx)
       if (!surf)
          continue;
 
-      /* glTextureView() is not applied to eglimage-backed surfaces, because it
-       * causes unintended format interpretation errors. But a swizzle may still
-       * be necessary, e.g. for rgb* views on bgr* resources. Ensure this
-       * happens by adding a shader swizzle to the final write of such surfaces.
+      /* Fragment shader output swizzle is needed in the following cases:
+       * 1. Cross-format view (RGBA resource, BGRA view or vice versa)
+       * 2. BGRA surface using GL_RGBA external format (gles_bgra_formats[])
+       *
+       * Case 1: glTextureView() is not applied to eglimage-backed surfaces,
+       * because it causes unintended format interpretation errors. But a swizzle
+       * may still be necessary, e.g. for rgb* views on bgr* resources. Ensure
+       * this happens by adding a shader swizzle to the final write of such surfaces.
+       *
+       * Case 2: In Core Profile mode, BGRA formats use GL_RGBA as external format
+       * (from gles_bgra_formats[]). The GPU stores data as RGBA internally, but the
+       * guest (Mesa) expects BGRA byte order. Fragment shader outputs must be
+       * swizzled from RGBA to BGRA to match the guest's expectation.
        */
-      if (vrend_resource_needs_redblue_swizzle(surf->texture, surf->format))
+      bool needs_swizzle = vrend_resource_needs_redblue_swizzle(surf->texture, surf->format);
+
+      /* Case 2: BGRA surface using GL_RGBA external format needs shader swizzle.
+       * This happens when using gles_bgra_formats[] (Core Profile mode). */
+      if (!needs_swizzle && vrend_format_is_bgra(surf->format)) {
+         const struct vrend_format_table *format_entry = &tex_conv_table[surf->format];
+         if (format_entry->glformat == GL_RGBA) {
+            VREND_DEBUG(dbg_bgra, sub_ctx->parent,
+                        "FB attachment %u: BGRA format using GL_RGBA external format, adding shader output swizzle\n",
+                        i);
+            needs_swizzle = true;
+         }
+      }
+
+      if (needs_swizzle)
          sub_ctx->swizzle_output_rgb_to_bgr |= 1 << i;
 
       /* glTextureView() on eglimage-backed bgr* textures for is not supported.
@@ -3209,6 +3232,10 @@ static void vrend_hw_emit_framebuffer_state(struct vrend_sub_context *sub_ctx)
       }
    }
 
+   VREND_DEBUG(dbg_bgra, sub_ctx->parent,
+               "FB state complete: swizzle_output_rgb_to_bgr=0x%x (nr_cbufs=%u)\n",
+               sub_ctx->swizzle_output_rgb_to_bgr, sub_ctx->nr_cbufs);
+
    glDrawBuffers(sub_ctx->nr_cbufs, buffers);
 }
 
@@ -4162,6 +4189,8 @@ static inline void vrend_sync_shader_io(struct vrend_sub_context *sub_ctx,
    if (type == PIPE_SHADER_FRAGMENT) {
       key->fs.lower_left_origin = !sub_ctx->fbo_origin_upper_left;
       key->fs.swizzle_output_rgb_to_bgr = sub_ctx->swizzle_output_rgb_to_bgr;
+      VREND_DEBUG(dbg_bgra, sub_ctx->parent,
+                  "Shader key: swizzle_output_rgb_to_bgr=0x%x\n", key->fs.swizzle_output_rgb_to_bgr);
       key->fs.needs_manual_srgb_encode_bitmask = sub_ctx->needs_manual_srgb_encode_bitmask;
       if (vrend_state.use_gles && can_emulate_logicop(sub_ctx->blend_state.logicop_func)) {
          key->fs.logicop_enabled = sub_ctx->blend_state.logicop_enable;
diff --git a/src/vrend/vrend_shader.c b/src/vrend/vrend_shader.c
index 4b47045..9bf8861 100644
--- a/src/vrend/vrend_shader.c
+++ b/src/vrend/vrend_shader.c
@@ -2672,7 +2672,12 @@ static void emit_cbuf_swizzle(const struct dump_ctx *ctx,
    for (uint32_t i = 0; i < ctx->num_outputs; i++) {
       if (ctx->outputs[i].name == TGSI_SEMANTIC_COLOR) {
          if (ctx->key->fs.swizzle_output_rgb_to_bgr & (1 << cbuf_id)) {
+            virgl_debug("SHADER SWIZZLE: Adding .zyxw swizzle to fsout_c%d (mask=0x%x)\n",
+                         cbuf_id, ctx->key->fs.swizzle_output_rgb_to_bgr);
             emit_buff(glsl_strbufs, "fsout_c%d = fsout_c%d.zyxw;\n", cbuf_id, cbuf_id);
+         } else {
+            virgl_debug("SHADER SWIZZLE: NOT swizzling fsout_c%d (mask=0x%x)\n",
+                         cbuf_id, ctx->key->fs.swizzle_output_rgb_to_bgr);
          }
          ++cbuf_id;
       }
    }
 }

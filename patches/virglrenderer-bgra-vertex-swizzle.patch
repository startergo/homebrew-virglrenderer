--- a/src/vrend/vrend_renderer.c
+++ b/src/vrend/vrend_renderer.c
@@ -898,6 +898,8 @@
                                       struct vrend_sampler_view *tview);
 static void vrend_object_bind_dsa_to_sub_context(struct vrend_sub_context *sub_ctx,
                                                  uint32_t handle);
+
+static void vrend_swizzle_data_bgra(uint64_t size, void *data);
 static GLenum tgsitargettogltarget(const enum pipe_texture_target target, int nr_samples);

 void vrend_update_stencil_state(struct vrend_sub_context *sub_ctx);
@@ -3514,7 +3516,47 @@
       vrend_report_context_error(ctx, VIRGL_ERROR_CTX_TOO_MANY_VERTEX_ATTRIBUTES, handle);
       return;
    }
+
+
+   /* In Core Profile, GL_BGRA vertex format is not supported.
+    * We need to swizzle vertex buffer data from BGRA to RGBA when zyxw_bitmask is set. */
+   if (vrend_state.use_core_profile && v->zyxw_bitmask) {
+      virgl_debug("[BGRA SWIZZLE] Binding vertex elements with zyxw_bitmask=0x%x, swizzling buffers\n", v->zyxw_bitmask);
+      for (uint32_t i = 0; i < v->count; i++) {
+         if (!(v->zyxw_bitmask & (1 << i)))
+            continue;
+
+         struct vrend_vertex_element *ve = &v->elements[i];
+         struct vrend_vertex_buffer *vbo = &ctx->sub->vbo[ve->base.vertex_buffer_index];
+         if (!vbo || !vbo->base.buffer) {
+            virgl_debug("[BGRA SWIZZLE] Element %u: no VBO/buffer\n", i);
+            continue;
+         }
+
+         struct vrend_resource *res = (struct vrend_resource *)vbo->base.buffer;
+         if (!res || res->base.target != PIPE_BUFFER || res->bgra_swizzled) {
+            if (res && res->bgra_swizzled)
+               virgl_debug("[BGRA SWIZZLE] Element %u: already swizzled\n", i);
+            else if (!res)
+               virgl_debug("[BGRA SWIZZLE] Element %u: no resource or not PIPE_BUFFER\n", i);
+            continue;
+         }
+
+         virgl_debug("[BGRA SWIZZLE] Element %u: mapping and swizzling (size=%u)\n", i, res->base.width0);
+         glBindBuffer(GL_ARRAY_BUFFER, res->gl_id);
+         void *data = glMapBufferRange(GL_ARRAY_BUFFER, 0, res->base.width0,
+                                        GL_MAP_WRITE_BIT | GL_MAP_READ_BIT);
+         if (data) {
+            vrend_swizzle_data_bgra(res->base.width0, data);
+            glUnmapBuffer(GL_ARRAY_BUFFER);
+            res->bgra_swizzled = true;
+            virgl_debug("[BGRA SWIZZLE] Element %u: successfully swizzled\n", i);
+         } else {
+            virgl_error("[BGRA SWIZZLE] Element %u: failed to map buffer\n", i);
+         }
+         glBindBuffer(GL_ARRAY_BUFFER, 0);
+      }
+   }
    if (has_feature(feat_gles31_vertex_attrib_binding)) {
       if (v->id == 0) {
       glGenVertexArrays(1, &v->id);
--- a/src/vrend/vrend_renderer.h
+++ b/src/vrend/vrend_renderer.h
@@ -121,6 +121,9 @@
    uint32_t blob_id;
    struct list_head head;
    bool is_imported;
+
+   /* Track if this vertex buffer has been swizzled from BGRA to RGBA */
+   bool bgra_swizzled;
 };

 #define VIRGL_TEXTURE_NEED_SWIZZLE        (1 << 0)

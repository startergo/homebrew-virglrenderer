--- a/src/vrend/vrend_renderer.h
+++ b/src/vrend/vrend_renderer.h
@@ -115,6 +115,9 @@
    uint32_t blob_id;
    struct list_head head;
    bool is_imported;
+
+   /* Track if vertex buffer data has been swizzled from BGRA to RGBA */
+   bool bgra_swizzled;
 };
 
 #define VIRGL_TEXTURE_NEED_SWIZZLE        (1 << 0)
--- a/src/vrend/vrend_renderer.c
+++ b/src/vrend/vrend_renderer.c
@@ -3458,10 +3458,55 @@
    if (has_feature(feat_gles31_vertex_attrib_binding) && v->id == 0) {
       glGenVertexArrays(1, &v->id);
       glBindVertexArray(v->id);
+
+   /* On macOS Core Profile, GL_BGRA vertex format is not available.
+    * When zyxw_bitmask indicates BGRA data, we need to swizzle the buffer
+    * data from BGRA to RGBA before the GPU reads it.
+    *
+    * This is called when vertex elements are bound, which happens after
+    * vertex buffer data has been uploaded. We swizzle the buffer data here
+    * to avoid having to track during upload. */
+   if (vrend_state.use_core_profile && v->zyxw_bitmask) {
       for (uint32_t i = 0; i < v->count; i++) {
-         struct vrend_vertex_element *ve = &v->elements[i];
-         GLint size = !vrend_state.use_gles && (v->zyxw_bitmask & (1 << i)) ? GL_BGRA : ve->nr_chan;
+         if (!(v->zyxw_bitmask & (1 << i)))
+            continue;
+
+         struct vrend_vertex_element *ve = &v->elements[i];
+         struct vrend_resource *res;
 
+         /* Find the resource bound to this vertex buffer */
+         if (ve->base.vertex_buffer_index >= ARRAY_SIZE(ctx->sub->vbo))
+            continue;
+
+         struct vrend_vertex_buffer *vbo = &ctx->sub->vbo[ve->base.vertex_buffer_index];
+         if (!vbo->base.buffer || vbo->base.buffer_offset == 0)
+            continue;
+
+         res = vrend_renderer_ctx_res_lookup(ctx, vbo->base.buffer);
+         if (!res || res->base.target != PIPE_BUFFER)
+            continue;
+
+         /* Check if we've already swizzled this buffer */
+         if (res->bgra_swizzled)
+            continue;
+
+         /* Map, swizzle BGRA->RGBA, and unmap the buffer */
+         glBindBuffer(GL_ARRAY_BUFFER, res->gl_id);
+         void *data = glMapBufferRange(GL_ARRAY_BUFFER, 0, res->base.width, GL_MAP_WRITE_BIT | GL_MAP_READ_BIT);
+         if (data) {
+            vrend_swizzle_data_bgra(res->base.width, data);
+            glUnmapBuffer(GL_ARRAY_BUFFER);
+            res->bgra_swizzled = true;
+            fprintf(stderr, "VREND: Swizzled BGRA vertex buffer %u (size=%lu)\n", vbo->base.buffer, res->base.width);
+         }
+         glBindBuffer(GL_ARRAY_BUFFER, 0);
+      }
+   }
+
+      for (uint32_t i = 0; i < v->count; i++) {
+         struct vrend_vertex_element *ve = &v->elements[i];
+         GLint size = (!vrend_state.use_gles && !vrend_state.use_core_profile) && (v->zyxw_bitmask & (1 << i)) ? GL_BGRA : ve->nr_chan;
+
          if (util_format_is_pure_integer(ve->base.src_format)) {
             UPDATE_INT_SIGN_MASK(ve->base.src_format, i,
                                  v->signed_int_bitmask,
@@ -5148,7 +5193,7 @@
          glUnmapBuffer(GL_ARRAY_BUFFER);
          disable_bitmask |= (1 << loc);
       } else {
-         GLint size = !vrend_state.use_gles && (va->zyxw_bitmask & (1 << i)) ? GL_BGRA : ve->nr_chan;
+         GLint size = (!vrend_state.use_gles && !vrend_state.use_core_profile) && (va->zyxw_bitmask & (1 << i)) ? GL_BGRA : ve->nr_chan;
 
          enable_bitmask |= (1 << loc);
          if (util_format_is_pure_integer(ve->base.src_format)) {
